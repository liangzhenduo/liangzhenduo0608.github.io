<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shintaku&#39;s Blog</title>
  
  <subtitle>いいこと？暁の水平線に勝利を刻みなさい！</subtitle>
  <link href="https://liangzhenduo0608.github.io/atom.xml" rel="self"/>
  
  <link href="https://liangzhenduo0608.github.io/"/>
  <updated>2020-11-22T09:53:59.757Z</updated>
  <id>https://liangzhenduo0608.github.io/</id>
  
  <author>
    <name>Shintaku</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>N1盒子Docker安装OpenWrt旁路由</title>
    <link href="https://liangzhenduo0608.github.io/posts/docker-openwrt/"/>
    <id>https://liangzhenduo0608.github.io/posts/docker-openwrt/</id>
    <published>2020-11-16T16:00:00.000Z</published>
    <updated>2020-11-22T09:53:59.757Z</updated>
    
    <content type="html"><![CDATA[<p>N1盒子装上Armbian以后就可以当作一台低功耗的小主机使用，配合各种docker可以集各种功能于一体。</p><p>Armbian固件使用的是恩山flippy大神的49+o（<a href="https://www.right.com.cn/forum/thread-981406-1-1.html">原帖地址</a>），目前已经稳定，于是在刷入u盘后顺手刷入了eMMC。</p><p>在刷入前先在u盘启动的系统里运行<code>ddbr</code>命令选<code>b</code>进行备份（记得选压缩），文件保存到了<code>/ddbr</code>目录，以便以后有需要时恢复原系统。<br>然后执行<code>install-to-emmc.sh</code>脚本按提示将系统拷贝到N1的闪存中。拷贝完成关机、拔U盘、再开机，就进入内置的系统了。</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><p>执行<code>install-docker.sh</code>安装docker，啪的一下就安装完成了，很快啊！</p><p>可以接着安装一个Docker图像化管理工具<a href="https://www.portainer.io/">Portainer</a>：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d --name portainer --restart always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><br>通过浏览器访问盒子的9000端口就能管理docker了。</p><h1 id="安装OpenWrt"><a href="#安装OpenWrt" class="headerlink" title="安装OpenWrt"></a>安装OpenWrt</h1><p>OpenWrt的Docker镜像使用的也是flippy大神提供的（<a href="https://www.right.com.cn/forum/thread-958173-1-1.html">原帖地址</a>），目前还在更新。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>从网盘上下载压缩包传到Armbian目录下，省去pull的步骤直接启动：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gzip -dc docker-img-openwrt-aarch64-r20.10.20.gz | docker load</span><br><span class="line">docker network create -d macvlan --subnet=192.168.123.0/24 --gateway=192.168.123.1 -o parent=eth0 macnet</span><br><span class="line">docker run -d --name openwrt --restart always --network macnet --privileged unifreq/openwrt-aarch64:r20.10.20</span><br></pre></td></tr></table></figure><br>其中macvlan的网段按主路由的实际情况填写。</p><h2 id="配置OpenWrt地址"><a href="#配置OpenWrt地址" class="headerlink" title="配置OpenWrt地址"></a>配置OpenWrt地址</h2><p>执行<code>docker exec -it openwrt bash</code>进入容器里进行配置。<br>编辑容器里的<code>/etc/config/network</code>配置文件，将<code>option ipaddr</code>的值改为指定给OpenWrt的ip地址，如<code>192.168.123.2</code>。<br>保存后执行<code>/etc/init.d/network restart</code>使配置生效。<br>此时通过浏览器访问刚刚配置的地址应该就可以进入luci管理界面了（默认密码应该是<code>password</code>）。</p><h2 id="旁路由设置"><a href="#旁路由设置" class="headerlink" title="旁路由设置"></a>旁路由设置</h2><p>通过浏览器进入OpenWrt的管理界面，在<code>网络</code>-<code>接口</code>里修改<code>lan</code>的配置，将<code>IPv4网关</code>设置为主路由的地址，如<code>192.168.123.1</code>，在<code>使用自定义的DNS服务器</code>里添加几个当地最好用的公共DNS；在<code>物理设置</code>里关闭<code>桥接接口</code>；关闭<code>DHCP服务器</code>里的<code>动态DHCP</code>功能，保存并与应用设置。</p><h2 id="主路由设置"><a href="#主路由设置" class="headerlink" title="主路由设置"></a>主路由设置</h2><p>在主路由的<code>内部网络(LAN)</code>-<code>DHCP服务器</code>设置里将<code>默认网关</code>和<code>DNS服务器</code>设置为旁路由地址，如<code>192.168.123.2</code>。<br>如果主路由是padavan固件且<code>外部网络(WAN)</code>-<code>外网设置</code>开启了硬件加速，需要将<code>IPv4 硬件加速</code>设置为<code>OFFLOAD TCP/UDP for LAN</code>。</p><h1 id="Armbian和OpenWrt网络互通"><a href="#Armbian和OpenWrt网络互通" class="headerlink" title="Armbian和OpenWrt网络互通"></a>Armbian和OpenWrt网络互通</h1><p>按照上面设置完旁路由发现Docker的宿主机Armbian系统和OpenWrt无法互相访问。需要修改Armbian网络配置<code>/etc/network/interfaces</code>，增加如下内容：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">up ip link <span class="built_in">set</span> eth0 promisc on</span><br><span class="line"></span><br><span class="line">auto macvlan</span><br><span class="line">iface macvlan inet static</span><br><span class="line">    address 192.168.123.123</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    gateway 192.168.123.1</span><br><span class="line">    dns-nameservers 192.168.123.1</span><br><span class="line">    pre-up ip link add macvlan link eth0 <span class="built_in">type</span> macvlan mode bridge</span><br><span class="line">    post-down ip link del macvlan link eth0 <span class="built_in">type</span> macvlan mode bridge</span><br></pre></td></tr></table></figure><br>其中<code>address</code>是要固定的Armbian的地址，<code>gateway</code>和<code>dns-nameservers</code>填主路由地址就可以了。</p><p>保存后执行<code>systemctl restart networking</code>使配置生效，两个地址就可以互相访问了。</p><p>然后在比硬路由更强大的N1盒子上就起一些留学服务了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;N1盒子装上Armbian以后就可以当作一台低功耗的小主机使用，配合各种docker可以集各种功能于一体。&lt;/p&gt;
&lt;p&gt;Armbian固件使用的是恩山flippy大神的49+o（&lt;a href=&quot;https://www.right.com.cn/forum/thread-</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="＊nix" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%EF%BC%8Anix/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="OpenWrt" scheme="https://liangzhenduo0608.github.io/tags/OpenWrt/"/>
    
    <category term="Docker" scheme="https://liangzhenduo0608.github.io/tags/Docker/"/>
    
    <category term="N1盒子" scheme="https://liangzhenduo0608.github.io/tags/N1%E7%9B%92%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Time Machine通过Samba备份到NAS</title>
    <link href="https://liangzhenduo0608.github.io/posts/tm-nas/"/>
    <id>https://liangzhenduo0608.github.io/posts/tm-nas/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-18T09:21:40.013Z</updated>
    
    <content type="html"><![CDATA[<p>MacBook升级后去掉了USB口，插移动硬盘比较麻烦，所以就一直没有备份时间机器了。后来觉得samba挂载的硬盘也可以用来备份，于是就想起了2019年捡垃圾时在某宝买的<strong>蜗牛星际</strong>矿渣（现在挂上硬盘装了OMV系统成为了一台家用NAS），希望可以无线局域网的环境下直接备份。</p><h1 id="OMV设置"><a href="#OMV设置" class="headerlink" title="OMV设置"></a>OMV设置</h1><h2 id="配置共享文件夹"><a href="#配置共享文件夹" class="headerlink" title="配置共享文件夹"></a>配置共享文件夹</h2><p>首先进入OMV控制台配置一个共享文件夹用于Time Machine的备份：</p><p><img src="/img/tm-nas-shared-folder.png" alt="共享文件夹"></p><p>这里我用了单独一块磁盘用于备份，并把文件夹命名为Backup。</p><p>配置完成后在<code>特权</code>里给用于备份的账户授予<code>读写权限</code>，并更改<code>ACL</code>设置如下：</p><p><img src="/img/tm-nas-acl.png" alt="修改ACL"></p><h2 id="更改samba设置"><a href="#更改samba设置" class="headerlink" title="更改samba设置"></a>更改samba设置</h2><p>以root身份登入OMV，编辑samba的配置文件<code>/etc/samba/smb.conf</code>，更改备份文件夹的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[Backup]</span><br><span class="line">comment &#x3D; Time Machine</span><br><span class="line">path &#x3D; &#x2F;srv&#x2F;dev-disk-by-label-Backup&#x2F;</span><br><span class="line">guest ok &#x3D; no</span><br><span class="line">guest only &#x3D; no</span><br><span class="line">read only &#x3D; no</span><br><span class="line">browseable &#x3D; yes</span><br><span class="line">inherit acls &#x3D; yes</span><br><span class="line">inherit permissions &#x3D; no</span><br><span class="line">ea support &#x3D; no</span><br><span class="line">store dos attributes &#x3D; no</span><br><span class="line">fruit:encoding &#x3D; private</span><br><span class="line">fruit:locking &#x3D; none</span><br><span class="line">fruit:metadata &#x3D; netatalk</span><br><span class="line">fruit:resource &#x3D; file</span><br><span class="line">fruit:time machine &#x3D; yes</span><br><span class="line">vfs objects &#x3D; catia fruit streams_xattr</span><br><span class="line">printable &#x3D; no</span><br><span class="line">create mask &#x3D; 0664</span><br><span class="line">force create mode &#x3D; 0664</span><br><span class="line">directory mask &#x3D; 0775</span><br><span class="line">force directory mode &#x3D; 0775</span><br><span class="line">hide special files &#x3D; yes</span><br><span class="line">follow symlinks &#x3D; yes</span><br><span class="line">hide dot files &#x3D; yes</span><br><span class="line">valid users &#x3D; &quot;shintaku&quot;</span><br><span class="line">invalid users &#x3D;</span><br><span class="line">read list &#x3D;</span><br><span class="line">write list &#x3D; &quot;shintaku&quot;</span><br></pre></td></tr></table></figure><p>主要变化在于更改了<code>vfs objects</code>的值并增加了几个<code>fruit</code>的配置。</p><p>保存后运行<code>testparm</code>看一下配置是否正确，没问题就可以<code>systemctl restart smbd</code>重启服务了。</p><h1 id="macOS设置"><a href="#macOS设置" class="headerlink" title="macOS设置"></a>macOS设置</h1><p>将Mac和NAS放到统一局域网下，用Finder的<code>前往</code>-<code>连接服务器</code>挂载一下备份硬盘看看是否正常。</p><h2 id="开启文件共享"><a href="#开启文件共享" class="headerlink" title="开启文件共享"></a>开启文件共享</h2><p>进入<code>系统偏好设置</code>-<code>共享</code>，在<code>文件共享</code>的选项里将SMB共享打勾：</p><p><img src="/img/tm-nas-sharing.png" alt="文件共享"></p><h2 id="配置时间机器"><a href="#配置时间机器" class="headerlink" title="配置时间机器"></a>配置时间机器</h2><p>进入<code>系统偏好设置</code>-<code>时间机器</code>，点<code>选择磁盘</code>：</p><p><img src="/img/tm-nas-select-disk.png" alt="选择磁盘"></p><p>发现在NAS上配置的共享磁盘已经出现了，选择这个磁盘会弹出窗口认证身份，填入之前授权过的用户名密码即可：</p><p><img src="/img/tm-nas-access.png" alt="登录"></p><p>然后就连接完成，可以开始备份了：</p><p><img src="/img/tm-nas-backup.png" alt="备份"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MacBook升级后去掉了USB口，插移动硬盘比较麻烦，所以就一直没有备份时间机器了。后来觉得samba挂载的硬盘也可以用来备份，于是就想起了2019年捡垃圾时在某宝买的&lt;strong&gt;蜗牛星际&lt;/strong&gt;矿渣（现在挂上硬盘装了OMV系统成为了一台家用NAS），希望可</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/macOS/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/tags/macOS/"/>
    
    <category term="OMV" scheme="https://liangzhenduo0608.github.io/tags/OMV/"/>
    
    <category term="NAS" scheme="https://liangzhenduo0608.github.io/tags/NAS/"/>
    
  </entry>
  
  <entry>
    <title>ShadowSocks启用v2ray-plugin</title>
    <link href="https://liangzhenduo0608.github.io/posts/shadowsocks-v2ray/"/>
    <id>https://liangzhenduo0608.github.io/posts/shadowsocks-v2ray/</id>
    <published>2019-11-10T16:00:00.000Z</published>
    <updated>2020-02-03T03:04:03.056Z</updated>
    
    <content type="html"><![CDATA[<p>2019年6月初由于某事件发生30周年，导致某长城突然加高，将大量机场IP屏蔽，于是将梯子改成了<strong>v2ray</strong>，并通过cloudflare代理DNS解析的方式将翻墙流量伪装成对域名的tls访问流量，曲线解决了IP端口被封的问题。<br>但是路由器上使用v2ray客户端有一些性能问题，总觉得不如原来的shadowsocks流畅，于是找到一种继续使用ss，并通过v2ray-plugin插件来伪装流量的方法。</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="搭建服务"><a href="#搭建服务" class="headerlink" title="搭建服务"></a>搭建服务</h2><p>停用原来的python版，安装shadowsocks-libev：</p><pre><code>yum install shadowsocks-libev -y</code></pre><p>克隆v2ray-plugin代码并编译（需要golang环境）：</p><pre><code>git clone https://github.com/shadowsocks/v2ray-plugin.gitcd v2ray-plugin &amp;&amp; go buildcp v2ray-plugin /usr/bin/</code></pre><h2 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h2><p>编辑<code>/etc/shadowsocks-libev/config.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>:<span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span>:<span class="number">23333</span>,</span><br><span class="line">    <span class="attr">&quot;local_port&quot;</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">&quot;password&quot;</span>:<span class="string">&quot;password&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>:<span class="string">&quot;rc4-md5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;plugin&quot;</span>:<span class="string">&quot;v2ray-plugin&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;plugin_opts&quot;</span>:<span class="string">&quot;server;loglevel=none&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来这里使用v2ray插件的目的是将shadowsocks的流量伪装成tls流量，自然服务器端口应当使用443。<br>但是我的服务器同时还启用了nginx，再使用443会造成端口冲突，所以在这里使用一个其他的端口，然后再用nginx做一次端口转发。</p><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在<code>/etc/nginx/conf.d/</code>目录下新建一个配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  ss.your.domain;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:23333;</span><br><span class="line">        <span class="attribute">proxy_redirect</span>      <span class="literal">off</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span>  <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>    Host $http_host;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>    Upgrade $http_upgrade;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>    Connection <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>server_name</code>需要使用自己的域名，并将这个二级域名解析到vps上。</p><p>保存后重启nginx，启动shadowsocks并设置开机启动：</p><pre><code>systemctl restart nginxsystemctl start shadowsocks-libevsystemctl enable shadowsocks-libev</code></pre><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>主要注意以下配置：</p><ul><li><code>服务器地址</code>填上面配置的<code>二级域名</code></li><li><code>服务器端口</code>填<code>443</code></li><li><code>插件名称</code>填<code>v2ray-plugin</code></li><li><code>插件参数</code>填<code>tls;host=二级域名</code></li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>此处以老毛子固件为例：</p><p><img src="/img/shadowsocks-v2ray-pdcn.png" alt="路由器设置"></p><p>打开开关应用即可。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><ul><li>客户端下载：<a href="https://github.com/shadowsocks/shadowsocks-windows/releases/latest">shadowsocks-windows</a></li><li>插件下载：<a href="https://github.com/shadowsocks/v2ray-plugin/releases/latest">v2ray-plugin</a></li></ul><p>下载完成将插件<code>v2ray-plugin.exe</code>解压到shadowsocks的文件夹中（使其与<code>shadowsocks.exe</code>平级），启动按如下配置：</p><p><img src="/img/shadowsocks-v2ray-windows.png" alt="Windows设置"></p><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><ul><li>客户端下载：<a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases/latest">ShadowsocksX-NG</a></li></ul><p>将客户端解压到应用目录（客户端会自己安装插件），启动按如下配置：</p><p><img src="/img/shadowsocks-v2ray-macos.png" alt="macOS设置"></p><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul><li>客户端下载：<a href="https://github.com/shadowsocks/shadowsocks-android/releases/latest">shadowsocks-android</a></li><li>插件下载：<a href="https://github.com/shadowsocks/v2ray-plugin-android/releases/latest">v2ray-plugin-android</a></li></ul><p>两个apk安装以后启动按如下配置：</p><p><img src="/img/shadowsocks-v2ray-android.png" alt="Android设置"><br><img src="/img/shadowsocks-v2ray-android-plugin.png" alt="插件设置"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2019年6月初由于某事件发生30周年，导致某长城突然加高，将大量机场IP屏蔽，于是将梯子改成了&lt;strong&gt;v2ray&lt;/strong&gt;，并通过cloudflare代理DNS解析的方式将翻墙流量伪装成对域名的tls访问流量，曲线解决了IP端口被封的问题。&lt;br&gt;但是路由</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
    <category term="VPS" scheme="https://liangzhenduo0608.github.io/tags/VPS/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="服务器" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="代理" scheme="https://liangzhenduo0608.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="ShadowSocks" scheme="https://liangzhenduo0608.github.io/tags/ShadowSocks/"/>
    
    <category term="V2Ray" scheme="https://liangzhenduo0608.github.io/tags/V2Ray/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客使用MathJax公式</title>
    <link href="https://liangzhenduo0608.github.io/posts/hexo-mathjax/"/>
    <id>https://liangzhenduo0608.github.io/posts/hexo-mathjax/</id>
    <published>2019-01-20T06:14:14.000Z</published>
    <updated>2019-07-14T15:04:34.205Z</updated>
    
    <content type="html"><![CDATA[<p>最近手贱将Hexo的博客的版本升到了3.8.0，顺便将npm组件也都升级了。一开始没有发现什么问题，后来打开一篇带公式的文章发现里面的部分<a href="https://www.mathjax.org/">MathJax</a>公式渲染失败了。想到之前曾经因为Markdown里面的下划线<code>_</code>表示斜体，和MathJax里的下标冲突了，之前改过的node_modules被更新覆盖了，这次索性重新搞一遍。</p><h1 id="更换渲染引擎"><a href="#更换渲染引擎" class="headerlink" title="更换渲染引擎"></a>更换渲染引擎</h1><p>卸载原来的<code>hexo-renderer-marked</code>，换成专门对MathJax魔改过的<code>hexo-renderer-kramed</code>（注意<code>kram</code>这个单词的拼写）：</p><pre><code>npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save</code></pre><p>再安装<code>hexo-renderer-mathjax</code>渲染器：</p><pre><code>npm install hexo-renderer-mathjax --save</code></pre><h1 id="更改字符集"><a href="#更改字符集" class="headerlink" title="更改字符集"></a>更改字符集</h1><p>为了避免语义冲突，修改<code>node_modules/kramed/lib/rules/inline.js</code>文件的<code>escape</code>和<code>em</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><h1 id="更改cdn链接"><a href="#更改cdn链接" class="headerlink" title="更改cdn链接"></a>更改cdn链接</h1><p>修改<code>node_modules/hexo-renderer-mathjax/mathjax.html</code>的最后一行，将<code>http</code>改成<code>https</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--script src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样是为了避免在网站为https协议时请求http的内容时被浏览器block。使用<code>hexo s</code>预览是否已生效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近手贱将Hexo的博客的版本升到了3.8.0，顺便将npm组件也都升级了。一开始没有发现什么问题，后来打开一篇带公式的文章发现里面的部分&lt;a href=&quot;https://www.mathjax.org/&quot;&gt;MathJax&lt;/a&gt;公式渲染失败了。想到之前曾经因为Markdo</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网站部署" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="JavaScript" scheme="https://liangzhenduo0608.github.io/tags/JavaScript/"/>
    
    <category term="Node.js" scheme="https://liangzhenduo0608.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>路由器TTL刷机救砖</title>
    <link href="https://liangzhenduo0608.github.io/posts/ttl/"/>
    <id>https://liangzhenduo0608.github.io/posts/ttl/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2020-01-18T10:04:34.327Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/ttldw22d.png" alt=""></p><p>之前偶然拿到一台大麦DW22D路由器，应该是之前的租客办长城宽带赠送的，登入管理界面发现里面是基于长城宽带深度定制的系统。</p><p><img src="/img/ttldomy.png" alt=""></p><p>上了恩山查了一下发现这个机器的硬件还可以，并且可以无拆机刷入padavan固件，所以就开始按照教程刷机。</p><h1 id="无拆机刷机"><a href="#无拆机刷机" class="headerlink" title="无拆机刷机"></a>无拆机刷机</h1><p>以下步骤参考<a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=313543">恩山的教程</a>。</p><h2 id="开启ssh"><a href="#开启ssh" class="headerlink" title="开启ssh"></a>开启ssh</h2><p>本方法主要依靠后门页面的命令注入漏洞，步骤如下：</p><h3 id="注入新密码"><a href="#注入新密码" class="headerlink" title="注入新密码"></a>注入新密码</h3><p>电脑连上路由器（最好有线方式），访问<a href="http://192.168.10.1/upgrade.html">http://192.168.10.1/upgrade.html</a>，在页面上打开ssh的选项，密码框内输入：</p><pre><code>123 | echo 6c216b27c8c9b051106c969e2077d4e9 &gt; /ezwrt/bin/upgrade_passwd </code></pre><p>注意末尾有空格。<strong>这里的md5值是<code>echo dfc643 | md5</code>算出来的，里面的<code>dfc643</code>是发现这个方法大佬的用户名，此处的密码是可以随便改的。</strong>然后点<code>确定</code>提交，此时会提示密码错误，可以忽略。</p><h3 id="注入ssh公钥"><a href="#注入ssh公钥" class="headerlink" title="注入ssh公钥"></a>注入ssh公钥</h3><p>再次访问<a href="http://192.168.10.1/upgrade.html">http://192.168.10.1/upgrade.html</a>，同样选择打开ssh，密码框内输入：</p><pre><code>123 | echo YOUR_ID_RSA_PUB &gt; /etc/dropbear/authorized_keys </code></pre><p>同样注意末尾有空格。<strong>其中<code>YOUR_ID_RSA_PUB</code>替换为自己的公钥，即电脑上<code>~/.ssh/id_rsa.pub</code>的内容。</strong>再次点<code>确定</code>提交，此时还会提示密码错误，也可以忽略。</p><h3 id="开启ssh-1"><a href="#开启ssh-1" class="headerlink" title="开启ssh"></a>开启ssh</h3><p>最后一次访问<a href="http://192.168.10.1/upgrade.html">http://192.168.10.1/upgrade.html</a>，选择打开ssh，密码为<code>dfc643</code>（如果在第一步注入密码时用了别的密码，此处输入相应的密码），最后点确定提交，提示<code>start ssh success</code>表示已经开启ssh。</p><p>这样就可以<code>ssh root@192.168.10.1</code>登录路由器了。</p><h2 id="刷入breed"><a href="#刷入breed" class="headerlink" title="刷入breed"></a>刷入breed</h2><p><a href="https://www.right.com.cn/forum/thread-161906-1-1.html">breed</a>是hackpascal独立开发的一个全新的 Bootloader。DW22D路由器对应的版本是<a href="https://breed.hackpascal.net/breed-mt7620-reset13.bin">breed-mt7620-reset13.bin</a>。</p><p>下载好后将其传入路由器的<code>/tmp</code>目录下备用：</p><pre><code>scp breed-mt7620-reset13.bin root@192.168.10.1:/tmp</code></pre><p>然后在路由器上执行：</p><pre><code>mtd_write -x mIp2osnRG3qZGdIlQPh1 -r write /tmp/breed-mt7620-reset13.bin bootloader</code></pre><p>这样应该就能将breed刷入bootloader，然后就可以随意刷firmware了。</p><p>然而我手残将最后的<code>bootloader</code>打成了<code>firmware</code>，也就是将breed刷入了firmware分区，导致路由器进不去系统了，也才有了后面的ttl救砖。</p><h1 id="TTL刷机"><a href="#TTL刷机" class="headerlink" title="TTL刷机"></a>TTL刷机</h1><p>以下步骤参考<a href="https://www.right.com.cn/forum/thread-190778-1-1.html">恩山的教程</a>。</p><h2 id="USB转TTL"><a href="#USB转TTL" class="headerlink" title="USB转TTL"></a>USB转TTL</h2><p>为了让路由器硬件和电脑相连，需要一个USB转TTL模块，随便在马云家买一个最便宜的就能用，我就买了一个<code>ch340g</code>芯片的模块。</p><h3 id="TTL驱动"><a href="#TTL驱动" class="headerlink" title="TTL驱动"></a>TTL驱动</h3><p>然后在github找了<a href="https://github.com/adrianmihalko/ch340g-ch34g-ch34x-mac-os-x-driver">驱动</a>安装上（这里给的是Mac电脑的驱动，Windows的驱动一般卖家都会提供，网上找找也都有）。</p><p>重启后打开<code>网络偏好</code>可以看见多了一个串行接口：</p><p><img src="/img/ttldriver.png" alt=""></p><p>将USB转TTL模块插在电脑上，在<code>/dev</code>目录下会出现名字类似<code>cu.usbserial-1410</code>的设备，说明识别成功。</p><h3 id="TTL连接"><a href="#TTL连接" class="headerlink" title="TTL连接"></a>TTL连接</h3><p>在如图位置焊上引脚（GND那个孔不用焊）：</p><p><img src="/img/ttlwiring.png" alt=""></p><p>然后用杜邦线将三个引脚和USB转TTL模块相连。</p><h2 id="开启TFTP"><a href="#开启TFTP" class="headerlink" title="开启TFTP"></a>开启TFTP</h2><p>将电脑用网线和路由器lan口连接，设置有线连接为手动模式，按图修改参数：</p><p><img src="/img/ttlnetwork.png" alt=""></p><p>参考<a href="/posts/mac-tftp/">macOS启用TFTP服务</a>，将<code>breed-mt7620-reset13.bin</code>放到TFTP目录下，将TFTP的地址选择有线ip（即上面设置的10.10.10.3）。</p><h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>一切就绪后，可以连接路由器开始刷机。</p><h3 id="登录路由器"><a href="#登录路由器" class="headerlink" title="登录路由器"></a>登录路由器</h3><p>使用screen连接未通电的路由器，波特率为57600：</p><pre><code>screen /dev/cu.usbserial-1410 57600</code></pre><p>此时终端里什么也没有。然后给路由器通电，此时会打印出很多东西，最后出现一些选项，立刻（5秒内）按数字键<code>9</code>选择TFTP刷机。</p><h3 id="刷入breed-1"><a href="#刷入breed-1" class="headerlink" title="刷入breed"></a>刷入breed</h3><p>之后会让确认<code>device IP</code>（路由器地址）和<code>server IP</code>（电脑地址），确认无误后会提示输入要刷入的文件名，输入<code>breed-mt7620-reset13.bin</code>回车就开始刷入了。</p><p>刷完后断电按住复位键通电并长按5秒即可进入breed：</p><p><img src="/img/ttlbreed.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/ttldw22d.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前偶然拿到一台大麦DW22D路由器，应该是之前的租客办长城宽带赠送的，登入管理界面发现里面是基于长城宽带深度定制的系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/ttldomy.p</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    <category term="ssh" scheme="https://liangzhenduo0608.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>macOS启用TFTP服务</title>
    <link href="https://liangzhenduo0608.github.io/posts/mac-tftp/"/>
    <id>https://liangzhenduo0608.github.io/posts/mac-tftp/</id>
    <published>2018-08-17T16:00:00.000Z</published>
    <updated>2019-07-14T15:04:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>TFTP在路由器刷机中被普遍使用，因为其协议简单，可以通过少量存储器实现。在PC上打开Windows功能就可启用。其实macOS也自带TFTP，只不过是没有自动启用。</p><p>TFTP默认使用的目录是<code>/private/tftpboot</code>，首先给其增加权限：</p><pre><code>sudo chmod -R 777 /private/tftpboot</code></pre><p>然后启用服务：</p><pre><code>sudo launchctl load -F /System/Library/LaunchDaemons/tftp.plistsudo launchctl start com.apple.tftpd</code></pre><p>如果觉得命令行方式不直观，macOS上也有类似Windows上的Tftpd32的应用<a href="http://ww2.unime.it/flr/tftpserver/">TFTP Server</a>，直接下载安装即可：</p><p><img src="/img/mactftpserver.png" alt=""></p><p>TFTP的目录也可以在应用中修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TFTP在路由器刷机中被普遍使用，因为其协议简单，可以通过少量存储器实现。在PC上打开Windows功能就可启用。其实macOS也自带TFTP，只不过是没有自动启用。&lt;/p&gt;
&lt;p&gt;TFTP默认使用的目录是&lt;code&gt;/private/tftpboot&lt;/code&gt;，首先给</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/macOS/"/>
    
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>搭建L2TP/IPSec VPN</title>
    <link href="https://liangzhenduo0608.github.io/posts/l2tp/"/>
    <id>https://liangzhenduo0608.github.io/posts/l2tp/</id>
    <published>2017-09-10T15:33:33.000Z</published>
    <updated>2019-07-14T15:04:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>之前曾经介绍过<a href="/posts/softether/">SoftEthern VPN</a>的搭建，最近换了新的VPS，需要重新搭建VPN，由于除了iOS以外的其他平台都可以用<a href="/posts/shadowsocks/">ShadowSocks</a>的梯子，就想搭建一个最简单的无需安装第三方App的VPN给iOS使用。想到系统自带的VPN可以连接<code>L2TP over IPSec</code>，就决定搭一个L2TP的VPN。</p><p>由于新VPS装的是CentOS 6，所以CentOS 7风格的命令就写在注释里了。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>先安装<code>openswan</code>和<code>xl2tpd</code>：</p><pre><code>yum install openswan xl2tpd</code></pre><p>如果没有<code>ppp</code>也要安装。</p><h1 id="配置IPSec"><a href="#配置IPSec" class="headerlink" title="配置IPSec"></a>配置IPSec</h1><p>在<code>/etc/ipsec.d</code>中新建一个<code>vpn.conf</code>文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">conn L2TP-PSK-NAT</span><br><span class="line">    rightsubnet&#x3D;vhost:%priv</span><br><span class="line">    also&#x3D;L2TP-PSK-noNAT</span><br><span class="line"></span><br><span class="line">conn L2TP-PSK-noNAT</span><br><span class="line">    authby&#x3D;secret</span><br><span class="line">    pfs&#x3D;no</span><br><span class="line">    auto&#x3D;add</span><br><span class="line">    keyingtries&#x3D;3</span><br><span class="line">    rekey&#x3D;no</span><br><span class="line">    ikelifetime&#x3D;8h</span><br><span class="line">    keylife&#x3D;1h</span><br><span class="line">    type&#x3D;transport</span><br><span class="line">    left&#x3D;YOUR_PUBLIC_IP_ADDRESS</span><br><span class="line">    leftprotoport&#x3D;17&#x2F;1701</span><br><span class="line">    right&#x3D;%any</span><br><span class="line">    rightprotoport&#x3D;17&#x2F;%any</span><br></pre></td></tr></table></figure><p>其中<code>left</code>的值改为VPS的公网IP。</p><p>再新建一个<code>vpn.secrets</code>文件，里面写一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YOUR_PUBLIC_IP_ADDRESS %any: PSK &quot;YOUR_PRE_SHARED_KEY&quot;</span><br></pre></td></tr></table></figure><p>前面还是公网IP，后面引号里面是自己设置的预共享密钥。</p><h1 id="更改系统参数"><a href="#更改系统参数" class="headerlink" title="更改系统参数"></a>更改系统参数</h1><p>编辑<code>/etc/sysctl.conf</code>文件，修改或添加成以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward &#x3D; 1</span><br><span class="line">net.ipv4.conf.default.rp_filter &#x3D; 0</span><br><span class="line">net.ipv4.conf.all.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.send_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.all.log_martians &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.log_martians &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.accept_source_route &#x3D; 0</span><br><span class="line">net.ipv4.conf.all.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects &#x3D; 0</span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses &#x3D; 1</span><br></pre></td></tr></table></figure><p>用<code>sysctl -p</code>命令使更改生效。</p><p>然后用以下脚本将<code>/proc/sys/net/ipv4/conf</code>下配置的值都改为<code>0</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> /proc/sys/net/ipv4/conf/*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> 0 &gt; <span class="variable">$each</span>/accept_redirects</span><br><span class="line">    <span class="built_in">echo</span> 0 &gt; <span class="variable">$each</span>/send_redirects</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="启动IPSec"><a href="#启动IPSec" class="headerlink" title="启动IPSec"></a>启动IPSec</h1><p>启动IPSec并加入开机启动：</p><pre><code>service ipsec start        #systemctl start ipsecchkconfig ipsec on        #systemctl enable ipsec</code></pre><p>然后用<code>ipsec verify</code>检查一下是否配置正确，正常如下：</p><pre><code>Version check and ipsec on-path                           [OK]Libreswan 3.15 (netkey) on 4.12.9-1.el6.elrepo.x86_64Checking for IPsec support in kernel                      [OK] NETKEY: Testing XFRM related proc values     ICMP default/send_redirects                          [OK]     ICMP default/accept_redirects                        [OK]     XFRM larval drop                                     [OK]Pluto ipsec.conf syntax                                   [OK]Hardware random device                                    [N/A]Two or more interfaces found, checking IP forwarding      [OK]Checking rp_filter                                        [OK]Checking that pluto is running                            [OK] Pluto listening for IKE on udp 500                       [OK] Pluto listening for IKE/NAT-T on udp 4500                [OK] Pluto ipsec.secret syntax                                [OK]Checking &#39;ip&#39; command                                     [OK]Checking &#39;iptables&#39; command                               [OK]Checking &#39;prelink&#39; command does not interfere with FIPSChecking for obsolete ipsec.conf options                  [OK]Opportunistic Encryption                                  [DISABLED]</code></pre><p>如果有异常请检查之前的配置。</p><h1 id="配置xl2tpd"><a href="#配置xl2tpd" class="headerlink" title="配置xl2tpd"></a>配置xl2tpd</h1><p>编辑<code>/etc/xl2tpd/xl2tpd.conf</code>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">listen-addr &#x3D; YOUR_PUBLIC_IP_ADDRESS</span><br><span class="line">ipsec saref &#x3D; yes</span><br><span class="line"></span><br><span class="line">[lns default]</span><br><span class="line">ip range &#x3D; 192.168.1.128-192.168.1.254</span><br><span class="line">local ip &#x3D; 192.168.1.99</span><br><span class="line">require chap &#x3D; yes</span><br><span class="line">refuse pap &#x3D; yes</span><br><span class="line">require authentication &#x3D; yes</span><br><span class="line">name &#x3D; LinuxVPNserver</span><br><span class="line">ppp debug &#x3D; yes</span><br><span class="line">pppoptfile &#x3D; &#x2F;etc&#x2F;ppp&#x2F;options.xl2tpd</span><br><span class="line">length bit &#x3D; yes</span><br></pre></td></tr></table></figure><p>其实主要注意监听地址和几个<code>yes</code>就行了，其他基本不用动。</p><p>然后编辑<code>/etc/ppp/options.xl2tpd</code>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ipcp-accept-local</span><br><span class="line">ipcp-accept-remote</span><br><span class="line">ms-dns8.8.8.8</span><br><span class="line">ms-dns8.8.4.4</span><br><span class="line">noccp</span><br><span class="line">auth</span><br><span class="line">crtscts</span><br><span class="line">idle 1800</span><br><span class="line">mtu 1410</span><br><span class="line">mru 1410</span><br><span class="line">nodefaultroute</span><br><span class="line">debug</span><br><span class="line">lock</span><br><span class="line">proxyarp</span><br><span class="line">connect-delay 5000</span><br></pre></td></tr></table></figure><p>在<code>/etc/ppp/chap-secrets</code>里添加帐号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># clientserversecretIP addresses</span><br><span class="line">username1*password1*</span><br><span class="line">username2*password2*</span><br></pre></td></tr></table></figure><p>按照对应格式填上帐号密码即可。</p><p>启动<code>xl2tpd</code>并加入开机启动：</p><pre><code>service xl2tpd start        #systemctl start xl2tpdchkconfig xl2tpd on        #systemctl enable xl2tpd</code></pre><p>最后在本地设备上填上地址、预共享密钥、用户名、密码就可以连接了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前曾经介绍过&lt;a href=&quot;/posts/softether/&quot;&gt;SoftEthern VPN&lt;/a&gt;的搭建，最近换了新的VPS，需要重新搭建VPN，由于除了iOS以外的其他平台都可以用&lt;a href=&quot;/posts/shadowsocks/&quot;&gt;ShadowSocks&lt;</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
    <category term="VPS" scheme="https://liangzhenduo0608.github.io/tags/VPS/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="服务器" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="代理" scheme="https://liangzhenduo0608.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="VPN" scheme="https://liangzhenduo0608.github.io/tags/VPN/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s Encrypt SSL证书配置</title>
    <link href="https://liangzhenduo0608.github.io/posts/certbot/"/>
    <id>https://liangzhenduo0608.github.io/posts/certbot/</id>
    <published>2017-06-18T14:22:22.000Z</published>
    <updated>2019-07-14T15:04:34.204Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://letsencrypt.org/">Let’s Encrypt</a>是一个于2015年三季度推出的数字证书认证机构，旨在以自动化流程消除手动创建和安装证书的复杂流程，并推广使万维网服务器的加密连接无所不在，为安全网站提供免费的SSL/TLS证书。</p><p>官方建议用<a href="https://www.eff.org/">EFF</a>开发的<a href="https://certbot.eff.org/">Certbot</a> ACME客户端签发证书。</p><h1 id="安装certbot"><a href="#安装certbot" class="headerlink" title="安装certbot"></a>安装certbot</h1><p>CentOS可以通过yum直接安装：</p><pre><code>yum install certbot</code></pre><p>如果yum找不到<code>certbot</code>，建议安装或重装<code>epel-release</code>。</p><h1 id="获取证书"><a href="#获取证书" class="headerlink" title="获取证书"></a>获取证书</h1><p>用以下命令对相应的若干域名生成证书：</p><pre><code>certbot certonly --webroot --email user@domain.com -w /usr/share/nginx/blog -d www.shintaku.cc -w /usr/share/nginx/info -d info.shintaku.cc</code></pre><p>然后在<code>/etc/letsencrypt/live/</code>下就会生成存放证书链接的目录，将它们配置到Web服务器就可以了。</p><h1 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><p>在<code>/etc/nginx/conf.d</code>新建<code>ssl.conf</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  www.shintaku.cc;</span><br><span class="line"></span><br><span class="line">    ssl                  on;</span><br><span class="line">    ssl_certificate      &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.shintaku.cc&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.shintaku.cc&#x2F;privkey.pem;</span><br><span class="line">    </span><br><span class="line">    ssl_session_cache shared:le_nginx_SSL:1m;</span><br><span class="line">    ssl_session_timeout 1440m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers &quot;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&quot;;</span><br><span class="line">    </span><br><span class="line">    add_header Strict-Transport-Security max-age&#x3D;31536000;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;blog;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page  404              &#x2F;404.html;</span><br><span class="line">    location &#x3D; &#x2F;404.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;blog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  info.shintaku.cc;</span><br><span class="line">    autoindex    on;</span><br><span class="line">    ssl                  on;</span><br><span class="line">    ssl_certificate      &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.shintaku.cc&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.shintaku.cc&#x2F;privkey.pem;</span><br><span class="line">    </span><br><span class="line">    ssl_session_cache shared:le_nginx_SSL:1m;</span><br><span class="line">    ssl_session_timeout 1440m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    ssl_ciphers &quot;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&quot;;</span><br><span class="line"></span><br><span class="line">    add_header Strict-Transport-Security max-age&#x3D;31536000;</span><br><span class="line">    </span><br><span class="line">    root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        index  index.html index.htm index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重载Nginx配置就可以了。可以到<a href="https://www.ssllabs.com/">SSL Labs</a>检测一下SSL状态。使用上述配置一般可以获得A+评分，也可以使用<a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/">Mozilla SSL Configuration Generator</a>生成配置。</p><p><img src="/img/certbotssl.png" alt="评分"></p><h1 id="证书续期"><a href="#证书续期" class="headerlink" title="证书续期"></a>证书续期</h1><p>Let’s Encrypt的证书有效期为90天，所以需要定期更新，离过期30天以内可以续期：</p><pre><code>certbot renew &amp;&amp; nginx -s reload</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://letsencrypt.org/&quot;&gt;Let’s Encrypt&lt;/a&gt;是一个于2015年三季度推出的数字证书认证机构，旨在以自动化流程消除手动创建和安装证书的复杂流程，并推广使万维网服务器的加密连接无所不在，为安全网站提供免费的SSL/TL</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网站部署" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="VPS" scheme="https://liangzhenduo0608.github.io/tags/VPS/"/>
    
    <category term="服务器" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Nginx" scheme="https://liangzhenduo0608.github.io/tags/Nginx/"/>
    
    <category term="SSL" scheme="https://liangzhenduo0608.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客部署到VPS</title>
    <link href="https://liangzhenduo0608.github.io/posts/hexo-deploy/"/>
    <id>https://liangzhenduo0608.github.io/posts/hexo-deploy/</id>
    <published>2017-06-08T15:33:33.000Z</published>
    <updated>2019-07-14T15:04:34.205Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo的博客本身之前是挂在<a href="http://liangzhenduo0608.github.io/">github.io</a>的，但是想用自己的域名，本来配一个CNAME就可以了，但是再想使用https就很麻烦了，索性就在VPS上也部署一份，自己运行维护。</p><h1 id="服务器hook配置"><a href="#服务器hook配置" class="headerlink" title="服务器hook配置"></a>服务器hook配置</h1><p>首先要装好Nginx，然后在<code>/usr/share/nginx</code>下新建一个临时目录：</p><pre><code>mkdir blog.git</code></pre><p>然后在里面创建git裸库：</p><pre><code>cd blog.gitgit init --barecd hooks</code></pre><p>之后就可以在<code>hooks</code>目录里配置自动执行的脚本了，编辑<code>post-receive</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -l</span></span><br><span class="line">GIT_REPO=/usr/share/nginx/blog.git</span><br><span class="line">PUBLIC_WWW=/usr/share/nginx/blog</span><br><span class="line">rm -rf <span class="variable">$PUBLIC_WWW</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$PUBLIC_WWW</span></span><br><span class="line">rm -rf <span class="variable">$PUBLIC_WWW</span>/.git</span><br></pre></td></tr></table></figure><p>记得给这个脚本添加执行权限：</p><pre><code>chmod +x post-receive</code></pre><p>通过这个hook就可以将新生成的博客放到<code>/usr/share/nginx/blog</code>下了。</p><h1 id="修改部署配置"><a href="#修改部署配置" class="headerlink" title="修改部署配置"></a>修改部署配置</h1><p>编辑本地Hexo仓库的<code>_config.yml</code>，在<code>deploy</code>下面增加一个新的配置，参考<a href="https://hexo.io/zh-cn/docs/deployment.html">官方文档</a>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">root@YOUR_VPS_IP:/usr/share/nginx/blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>保存后使用<code>hexo d</code>命令重新部署，在这之前确认一下是否已经配置过VPS的公私钥登录。部署完成后到VPS的<code>/usr/share/nginx</code>下看是否出现<code>blog</code>目录，且里面是Hexo生成的页面内容。</p><h1 id="服务器Nginx配置"><a href="#服务器Nginx配置" class="headerlink" title="服务器Nginx配置"></a>服务器Nginx配置</h1><p>进入<code>/etc/nginx/conf.d</code>目录新建一个配置文件<code>blog.conf</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.shintaku.cc;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/blog;</span><br><span class="line">        <span class="attribute">index</span>  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">404</span>              /<span class="number">404</span>.html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后用<code>nginx -s reload</code>重载配置，打开上面配置的域名（首先应该配置过解析）应该就能访问Hexo博客了。这样只是http访问，之后可以按需配置https，这里不再赘述。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hexo的博客本身之前是挂在&lt;a href=&quot;http://liangzhenduo0608.github.io/&quot;&gt;github.io&lt;/a&gt;的，但是想用自己的域名，本来配一个CNAME就可以了，但是再想使用https就很麻烦了，索性就在VPS上也部署一份，自己运行维护。</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网站部署" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="VPS" scheme="https://liangzhenduo0608.github.io/tags/VPS/"/>
    
    <category term="服务器" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Nginx" scheme="https://liangzhenduo0608.github.io/tags/Nginx/"/>
    
    <category term="Git" scheme="https://liangzhenduo0608.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>向量空间中词表征的有效估计</title>
    <link href="https://liangzhenduo0608.github.io/posts/word2vec/"/>
    <id>https://liangzhenduo0608.github.io/posts/word2vec/</id>
    <published>2017-05-20T12:20:20.000Z</published>
    <updated>2019-07-14T15:04:34.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://arxiv.org/pdf/1301.3781.pdf">Efficient Estimation of Word Representations in Vector Space</a><br>源码：<a href="https://code.google.com/archive/p/word2vec/">word2vec</a></p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文提出了两种新的模型结构，用于计算大型数据集中单词的连续向量表征。这些表征的质量是在单词相似性任务中衡量出来的，并将结果与​​之前基于不同类型<a href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">神经网络</a>（neural network）的最佳效果进行比较。我们观测到在低计算成本的精度上有大幅提高，只用不到一天的时间从16亿单词中学到高质量的词向量。此外，我们展示了这些向量在衡量句法和词义相似性上保证了最先进的性能。</p><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>当今先进的自然语言处理系统与技术都把词作为原子单元。总是被用作词表的索引，而不去考虑词间的相似性。这样做的好处在于简单且健壮，而且观察到简单模型在大量数据上训练的性能优于复杂模型在少量数据上的训练。统计语言模型中的<a href="https://zh.wikipedia.org/wiki/N%E5%85%83%E8%AF%AD%E6%B3%95">N-gram</a>就是这样的典型例子，几乎可以在所有可用数据上训练（万亿词量）。</p><p>然而简单的技术在很多领域都有其局限性。例如相关领域内的自动语音识别数据是有限的，简单模型的性能通常取决于转录的高质量的语音数据的大小，通常只有几百万的词。在机器翻译中，很多语音的已有的语料库的大小也只有几十亿。因此，对这些基本技术的简单升级并不会带来很大的性能提升，我们不得不考虑更复杂的高级技术。</p><p>随着机器学习技术的发展，训练更大规模数据上的复杂模型成为可能，它们要远远超过那些简单模型。可能最成功的概念就是使用<strong>分布式词表征</strong>（distributed representations of words），例如基于神经网络的语言模型远优于N-gram模型。</p><h2 id="本文目标"><a href="#本文目标" class="headerlink" title="本文目标"></a>本文目标</h2><p>本文的主要目标是介绍一种能从几十亿的语料库与几百万的词表的巨大数据集中学习高质量词表征的技术。据我们所知，迄今为止没有任何一个框架能以50～100维的词向量成功训练上亿的词表。</p><p>使用最近提出的一项技术来衡量得到的向量表征的质量，该度量指标不但期望意思相近的词表征相近，而且还能表示词的<strong>多种相似性程度</strong>（multiple degrees of similarity）。这常见于<a href="https://zh.wikipedia.org/wiki/%E5%B1%88%E6%8A%98%E8%AF%AD">屈折语</a>（inflectional language）中，例如名词可能有多种词尾（后缀），如果在原始的向量子空间中搜索相似词，可能找到的是具有相似词尾的词。</p><p>令人惊讶的是词表征的相似性远远超出了简单的语法规则。使用词偏置技术时，对词向量进行简单的代数操作，例如<em>vector(“King”)-vector(“Man”)+vector(“Woman”)</em>得到的向量与<em>Queen</em>比较近。</p><p>本文通过开发新的模型结构来最大化向量操作的精度，从而保留词间的线性规则。我们设计了一个综合的测试集从语法和语义规则两方面衡量，以此来展示该模型可以以很高的精度学习到许多规则，并进一步讨论了模型的训练时间和精度取决于词向量的维度和训练数据集的大小。</p><h2 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h2><p>将词表示为连续的向量的思想由来已久。一个很受欢迎的模型结构称为<strong>神经网络语言模型</strong>（neural network language model, NNLM），采用一个线性投影层加上一个非线性隐藏层来同时学习到词向量表征和统计语言模型。该工作得到后续很多工作的参考。</p><p>另一个有趣的NNLM结构是先用一个隐藏层的神经网络来学习词向量，再使用这些词向量来训练NNLM。因此，词向量的学习不需要构建完整的NNLM。本文对这个结构进一步扩展，致力于使用一个简单的模型来学习词向量表征。</p><p>后续会展示词向量表征可以用来显著改善和简化许多NLP应用。词向量本身的估计可以采用多种模型结构，在多种语料库上训练，其中一些学习到的词向量表征可以用作进一步的研究和对比。然而，据我们所知，这些模型的计算代价要远远高于最早的模型，一个例外是<a href="http://machinelearning.wustl.edu/mlpapers/paper_files/icml2007_MnihH07.pdf">mnih2007three</a>中提出的采用对角权重矩阵的<strong>log-bilinear</strong>模型。</p><h1 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h1><p>许多已经提出的不同的模型可以用来估计词的连续向量表征，包括广为人知的<a href="https://zh.wikipedia.org/wiki/%E6%BD%9C%E5%9C%A8%E8%AF%AD%E4%B9%89%E5%AD%A6">潜在语义分析</a>（Latent Semantic Analysis, LSA）以及<a href="https://zh.wikipedia.org/wiki/%E9%9A%90%E5%90%AB%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%88%86%E5%B8%83">隐含狄利克雷分布</a>（Latent Dirichlet Allocation, LDA）。本文着重于用神经网络学习词的分布式表征，已有的工作表明，与LSA相比分布式表征可以更好的保留词间的线性规则。而LDA最大的缺点在于大数据集上的计算复杂度高。</p><p>比较不同模型结构，首先用完整的训练模型所需要的参数的数量来定义模型计算的复杂度。接下来试图最大化精度，同时最小化计算复杂度。对于下面所有模型，训练复杂度遵循：</p><script type="math/tex; mode=display">O=E\times T\times Q</script><p>其中\(E\)表示训练次数，\(T\)表示训练集单词数，\(Q\)表示模型结构进一步定义。通常\(E\)在3～50之间，\(T\)高达十亿。所有的模型采用<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">随机梯度下降</a>和<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95">反向传播</a>。</p><h2 id="前馈NNLM"><a href="#前馈NNLM" class="headerlink" title="前馈NNLM"></a>前馈NNLM</h2><p>概率<strong>前馈神经网络语言模型</strong>（Feedforward NNLM）包括<strong>输入</strong>（input）、<strong>投影</strong>（projection）、<strong>隐藏</strong>（hidden）、<strong>输出</strong>（output）四层。输入层中，前\(N\)个词编码为1-of-\(V\)，\(V\)为词表大小。输入层映射到\(N\times D\)维的投影层\(P\)。由于在任何时刻，仅\(N\)个输入是激活的，因此投影层的组合是相对简单的操作。</p><p>NNLM结构的复杂计算在于投影层和隐藏层之间的计算，主要原因是投影层是稠密的。对于一个常见的选择\(N=10\)，投影层\(P\)的大小可能为500～2000，而隐藏层\(H\)的大小通常为500～1000。更进一步讲，隐藏层通常用来计算在整个词表上的概率分布，输出层的结果是\(V\)维的。因此每个训练实例的计算复杂度为：</p><script type="math/tex; mode=display">Q=N\times D+N\times D\times H+H\times V</script><p>其中\(H\times V\)起决定作用。然而为了避免如此提出了一些实际的解决方案：使用<strong>Hierarchical Softmax</strong>，或者在训练的时候使用未归一化的模型来避免对模型的归一化。采用词表的二叉树表示，可以将输出单元的数量降低到\(\log_2(V)\)。这样模型的主要复杂度就在\(N\times D\times H\)了。</p><p>本文的模型采用Hierarchical Softmax，其中词表表示为霍夫曼树。这样做主要是基于之前观测到的一个现象：词频对于在NNLM上获取分类非常有效。霍夫曼树给频繁出现的词以较短的编码，这样进一步减少了输出单元的数量。而平衡二叉树需要\(\log_2(V)\)输出来评估，基于霍夫曼树的Hierarchical Softmax仅仅需要\(\log_2(Unigram_perplexity(V))\)。例如当词表大小为100万时计算效率得到了两倍的加速。虽然对于NNLM来讲不是最关键的加速，因为主要的计算瓶颈在于\(N\times D\times H\)，后续提出的模型结构并没有隐藏层，而是主要取决于Softmax正则化。</p><h2 id="递归NNLM"><a href="#递归NNLM" class="headerlink" title="递归NNLM"></a>递归NNLM</h2><p><strong>递归神经网络语言模型</strong>（Recurrent NNLM）的提出是为了克服前馈NNLM的一些局限性，例如需要指定上下文的长度（模型阶数N），因此理论上讲<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C">递归神经网络</a>（recurrent neural network）可以比<strong>浅层神经网络</strong>（shallow neural networks）更高效的表示更复杂的模式。RNN并没有投影层，只有输入、隐藏、输出三层。这类模型的特殊性在于递归矩阵，该矩阵用时间延迟将隐藏层与自身连接起来。这就允许递归模型形式化某种短时记忆，因为之前的信息能够表示为隐藏层中的状态，该状态可以根据当前的输入以及上个时间步的状态进行更新。</p><p>RNN模型对于一个训练实例的时间复杂度是：</p><script type="math/tex; mode=display">Q=H\times H+H\times V</script><p>其中词表征\(D\)具有与隐藏层\(H\)相同的维度。我们同样可以使用Hierarchical Softmax将\(H\times V\)有效降低为\(H\times\log_2(V)\)。主要计算复杂度在于\(H\times H\)。</p><h2 id="神经网络的并行训练"><a href="#神经网络的并行训练" class="headerlink" title="神经网络的并行训练"></a>神经网络的并行训练</h2><p>在大规模数据集上训练模型时，已经基于大规模分布式框架<a href="https://zh.wikipedia.org/wiki/TensorFlow#DistBelief">DistBlief</a>实现了几个模型包括前馈NNLM以及本文中提出的新模型。该框架支持并行运行一个模型的多个副本，每个副本通过保持参数一致的中央服务器来同步梯度更新。对于并行训练，我们采用自适应的学习速率下的<strong>mini-batch异步梯度下降</strong>，整个过程称为<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent#AdaGrad">Adagrad</a>。在这种框架下，通常一个数据中心使用100多个模型副本，每个副本使用不同机器的多核。</p><h1 id="对数线性模型"><a href="#对数线性模型" class="headerlink" title="对数线性模型"></a>对数线性模型</h1><p>本节提出两个以最小化计算复杂度来学习分布式词表征的模型结构。前文观测结果表明：模型计算的主要复杂度来自于非线性隐藏层。尽管这些隐藏层使神经网络更优雅，本文还是决定使用可能没有神经网络数据精确的更为简单的模型，但是至少能够高效的训练更多的数据。</p><p>新结构的提出主要基于之前发现的NNLM可以通过两步进行训练：</p><ul><li>使用简单模型学习连续词向量表征</li><li>基于分布式词表征训练N-gram神经网络语言模型</li></ul><h2 id="连续Bag-of-Words模型"><a href="#连续Bag-of-Words模型" class="headerlink" title="连续Bag-of-Words模型"></a>连续Bag-of-Words模型</h2><p><img src="/img/w2vcbow.png" alt="CBOW"></p><p>首先提出的结构类似于前馈NNLM，去掉了其中的非线性隐层，所有词共享投影层（不只是投影矩阵）；所有的词投影到相同的位置（向量平均）。因为历史词序并不能影响投影，所以把这个结构称为<a href="https://zh.wikipedia.org/wiki/%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B">词袋模型</a>（bag-of-words）。更何况也使用了未来的词。在下节提到的任务中，使用4个未来词和4个历史词作为输入取得了最优的性能，其中优化目标是能准确对当前词分类。训练复杂度为：</p><script type="math/tex; mode=display">Q=N\times D+D\times\log_2(V)</script><p>将这个模型记为<strong>CBOW</strong>。与标准词袋模型不同，它使用上下文的连续分布式表征。注意输入层与投影层之间的权重矩阵与NNLM一样是所有词位置共享的。</p><h2 id="连续Skip-Gram模型"><a href="#连续Skip-Gram模型" class="headerlink" title="连续Skip-Gram模型"></a>连续Skip-Gram模型</h2><p><img src="/img/w2vskip.png" alt="Skip-gram"></p><p>第二个结构与CBOW类似，不同的是CBOW基于上下文预测当前词，这个模型尝试根据同一句子中的另外一个词来最大化一个词的分类。更准确的说法，使用当前词作为有连续投影层的对数线性分类器的输入，来预测词语所在当前词的前后范围。发现增加窗口的大小可以提高学习到的词向量的质量，但也增加了计算复杂度。因为离得越远的词通常与当前词越不相关，所以给那些离得较远的词较小的权重使得其被采样的概率变小。该结构的训练复杂度正比于：</p><script type="math/tex; mode=display">Q=C\times(D+D\times\log_2(V))</script><p>其中\(C\)为词间的最大距离，对于每个训练词从\(<1;C>\)范围内选择随机数\(R\)，使用\(R\)个历史词与\(R\)个未来词作为当前词的标签。这就需要做\(R\times2\)个词分类，将当前词作为输入，\(R+R\)中的每个词作为输出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://arxiv.org/pdf/1301.3781.pdf&quot;&gt;Efficient Estimation of Word Representations in Vector Space&lt;/a&gt;&lt;br&gt;源码：&lt;a h</summary>
      
    
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VPS开启TCP-BBR拥塞控制</title>
    <link href="https://liangzhenduo0608.github.io/posts/tcp-bbr/"/>
    <id>https://liangzhenduo0608.github.io/posts/tcp-bbr/</id>
    <published>2017-05-11T03:11:11.000Z</published>
    <updated>2019-07-14T15:04:34.207Z</updated>
    
    <content type="html"><![CDATA[<p>早就听说Google又搞出了<a href="https://github.com/google/bbr">BBR</a>这样的黑科技，能在有一定丢包率的网络链路上充分利用带宽并降低延迟，起到了玄学般的加速效果，比<strong>锐速</strong>不知道高到哪里去了，简直是梯子用户的福音。由于需要升级内核，有影响VPS上服务的风险，就一直没动。现在机器闲下来了，又赶上余额快用完了，就趁机乱搞一发。</p><h1 id="更新内核"><a href="#更新内核" class="headerlink" title="更新内核"></a>更新内核</h1><p>首先更新一下系统：</p><pre><code>yum update -y</code></pre><p>然后添加<a href="http://elrepo.org/">ELRepo</a>源来更新4.9及以上版本的内核：</p><pre><code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.orgrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install kernel-ml -y</code></pre><p>安装完后检查一下是否安装成功：</p><pre><code>awk -F\&#39; &#39;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#39; /etc/grub2.cfg</code></pre><p>如果没有其他问题一般来说新安装的内核会出现在第一行：</p><pre><code>0 : CentOS Linux (4.11.0-1.el7.elrepo.x86_64) 7 (Core)1 : CentOS Linux 7 Rescue f4cdc05ef89d44228e2623a70209bbce (3.10.0-327.28.3.el7.x86_64)2 : CentOS Linux (3.10.0-327.28.3.el7.x86_64) 7 (Core)3 : CentOS Linux (3.10.0-327.28.2.el7.x86_64) 7 (Core)4 : CentOS Linux (0-rescue-3839f3a1ba354857903e239a272e6cec) 7 (Core)</code></pre><p>然后将最新的内核（编号为0的）设为默认内核：</p><pre><code>grub2-set-default 0</code></pre><p>然后<code>reboot</code>重启就可以了；如果是DigitalOcean的VPS建议先<code>poweroff</code>关机，然后到控制台把Kernel改成<code>DigitalOcean GrubLoader v0.2</code>，然后再开机：</p><p><img src="/img/bbrkernel.png" alt=""></p><h1 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h1><p>开机后先<code>uname -r</code>确认一下内核是否更换成功，如果没问题就编辑<code>/etc/sysctl.conf</code>加入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc &#x3D; fq</span><br><span class="line">net.ipv4.tcp_congestion_control &#x3D; bbr</span><br></pre></td></tr></table></figure><p>保存后执行<code>sysctl -p</code>生效。然后查看TCP配置：</p><pre><code>sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control</code></pre><p>如果<code>=</code>后面都有<code>bbr</code>出现则说明设置成功。执行：</p><pre><code>lsmod | grep tcp_bbr</code></pre><p>如果有<code>tcp_bbr</code>则说明已开启。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;早就听说Google又搞出了&lt;a href=&quot;https://github.com/google/bbr&quot;&gt;BBR&lt;/a&gt;这样的黑科技，能在有一定丢包率的网络链路上充分利用带宽并降低延迟，起到了玄学般的加速效果，比&lt;strong&gt;锐速&lt;/strong&gt;不知道高到哪里去了，简</summary>
      
    
    
    
    <category term="网络" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/categories/%E7%BD%91%E7%BB%9C/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
    <category term="VPS" scheme="https://liangzhenduo0608.github.io/tags/VPS/"/>
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="服务器" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="代理" scheme="https://liangzhenduo0608.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>大型属性网络的语义社团识别</title>
    <link href="https://liangzhenduo0608.github.io/posts/sci/"/>
    <id>https://liangzhenduo0608.github.io/posts/sci/</id>
    <published>2017-04-28T07:15:15.000Z</published>
    <updated>2019-07-14T15:04:34.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="http://www.cse.wustl.edu/~zhang/publications/aaai16-attributenetworks.pdf">Semantic community identification in large attribute networks</a></p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>网络的模块或社团结构的识别是理解网络语义和功能的关键。虽然已经开发了许多主要探索网络拓扑的社区检测方法，但它们只提供了少量语义信息的社团发现。尽管结构和语义密切相关，但在一起发现并分析这两个基本网络属性上只做了很少的工作。通过在节点上整合网络拓扑和语义信息，如节点属性，研究了社团检测并同时推断其语义的问题。本文提出了一种具有两组参数，社团成员矩阵和社团属性矩阵的新型<a href="https://en.wikipedia.org/wiki/Non-negative_matrix_factorization">非负矩阵因式分解</a>（NMF）模型，并提出了有效的更新规则保证收敛地评估参数。节点属性的使用改进了社团检测，并为所得到的网络社团提供了语义解释。在人造和真实的世界网络上的广泛实验结果不仅显示了新方法较先进方法的优越性能，而且还展示了其对社团的语义注释能力。</p><h1 id="SCI模型"><a href="#SCI模型" class="headerlink" title="SCI模型"></a>SCI模型</h1><p>考虑一个有\(n\)个节点\(V\)和\(e\)条边\(E\)的无向网络\(G=(V,E)\)，用二值邻接矩阵\(\mathbf{A}\in\mathbb{R}^{n\times n}\)表示。与每个节点\(i\)相关联的是其属性\(\mathbf{S}_i\)，其可以是节点的语义特征。节点的属性是\(m\)维二值向量形式的，所有节点的属性可以由节点属性矩阵\(\mathbf{S}\in\mathbb{R}^{n\times m}\)表示。社团识别的问题是将网络\(G\)划分为\(k\)个社团，并推断每个社团的相关属性或语义。</p><h2 id="建模网络拓扑"><a href="#建模网络拓扑" class="headerlink" title="建模网络拓扑"></a>建模网络拓扑</h2><p>将属于社团\(j\)的节点\(i\)的先验定义为\(U_{ij}\)。网络中所有节点的社团成员为\(\mathbf{U}=(U_{ij})\)，其中\(i=1,2,\ldots,n\)且\(j=1,2,\ldots,k\)。因此\(U_{ir}U_{pr}\)表示社团\(r\)中节点\(i\)和\(p\)之间边数的期望。对所有社团求和，\(i\)和\(p\)之间边数的期望是\(\sum_{r=1}^kU_{ir}U_{pr}\)。 这种生成边的过程意味着如果两个节点具有相似的社团关系，则它们具有更高的连接倾向。节点对之间的期望边数应尽可能与由\(\mathbf{A}\)表示的网络拓扑一致，在矩阵行列式上产生以下函数：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{U}\ge0}\|\mathbf{A}-\mathbf{UU}^T\|_F^2</script><h2 id="建模节点属性"><a href="#建模节点属性" class="headerlink" title="建模节点属性"></a>建模节点属性</h2><p>定义社团\(r\)具有属性\(q\)的倾向为\(C_{qr}\)。因此对于所有社团，有一个社团属性矩阵\(\mathbf{C}=(C_{qr})\)，对于\(q=1,2,\ldots,m\)和\(r=1,2,\ldots,k\)，其中第\(r\)列\(\mathbf{C}_r\)是社团\(r\)的属性成员。如果节点的属性与社团的属性高度相似，那么该节点可能更倾向于在这个社团中。 因此，在\(S_i\)中描述的具有相似属性的节点可能形成一个社团，其可由节点的一般属性来描述。特别地，节点\(i\)属于社团\(r\)的倾向可表示为\(U_{ir}=\mathbf{S}_i\mathbf{C}_r\)。注意如果节点\(i\)和社团\(r\)的属性完全不一致，则节点\(i\)一定不属于社团\(r\)，即\(U_{ir}=0\)。由于所有节点\(mathbf{U}\)的社团成员为结合节点和社团的属性提供了指导，有以下优化函数：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{C}\ge0}\|\mathbf{U}-\mathbf{SC}\|_F^2</script><p>为了给每个社团选择最相关的属性，为矩阵\(\mathbf{C}\)的每列添加一个\(l_1\)稀疏范数。另外为了防止\(\mathbf{C}\)的一些列的值过大（每个社团都有一些有意义的属性），对\(\mathbf{C}\)有约束\(\sum_{j=1}^k|\mathbf{C}(:,j)|_1^2\)，产生以下目标函数：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{C}\ge0}\|\mathbf{U}-\mathbf{SC}\|_F^2+\alpha\sum_{j=1}^k\|\mathbf{C}(:,j)\|_1^2</script><p>其中\(\alpha\)是权衡第一误差项和第二稀疏项的非负参数。</p><h2 id="统一模型"><a href="#统一模型" class="headerlink" title="统一模型"></a>统一模型</h2><p>通过结合网络拓扑模型和节点属性模型的目标函数，有以下完整函数：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{U}\ge0,\mathbf{C}\ge0}L=\|\mathbf{U}-\mathbf{SC}\|_F^2+\alpha\sum_{j=1}^k\|\mathbf{C}(:,j)\|_1^2+\beta\|\mathbf{A}-\mathbf{UU}^T\|_F^2</script><p>其中\(\beta\)是调整网络拓扑权重的正参数。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>由于上面的目标函数不是凸的，所以获得最优解不切实际。局部最小值可以使用<a href="https://en.wikipedia.org/wiki/MM_algorithm">专门化-最小化</a>框架来实现。这里描述一个固定\(\mathbf{C}\)迭代更新\(\mathbf{U}\)然后固定\(\mathbf{U}\)迭代更新\(\mathbf{C}\)的算法，这保证在每次迭代之后不增加目标函数。具体公式展示为如下两个子问题。</p><h2 id="U问题"><a href="#U问题" class="headerlink" title="U问题"></a><em>U</em>问题</h2><p>当固定\(\mathbf{C}\)更新\(\mathbf{U}\)时，需要解决以下问题：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{U}\ge0}L(\mathbf{U})=\|\mathbf{U}-\mathbf{SC}\|_F^2+\beta\|\mathbf{A}-\mathbf{UU}^T\|_F^2</script><p>为此为\(\mathbf{U}\)上的非负约束引入拉格朗日乘数矩阵\(\mathbf{\Theta}=(\Theta_{ij})\)，得到以下等价目标函数：</p><script type="math/tex; mode=display">L(\mathbf{U})=tr(\mathbf{UU}^T-\mathbf{UC}^T\mathbf{S}^T-\mathbf{SCU}^T+\mathbf{SCC}^T\mathbf{S}^T)+\beta tr(\mathbf{AA}-\mathbf{AUU}^T-\mathbf{UU}^T\mathbf{A}+\mathbf{UU}^T\mathbf{UU}^T)+tr(\mathbf{\Theta U}^T)</script><p>将对\(\mathbf{U}\)的导数\(L(\mathbf{U})\)设为0，有：</p><script type="math/tex; mode=display">\mathbf{\Theta}=-2\mathbf{U}+2\mathbf{SC}+4\beta\mathbf{AU}-4\beta\mathbf{UU}^T\mathbf{U}</script><p>根据对非负\(\mathbf{U}\)的<a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%BE%85%E9%9C%80%EF%BC%8D%E5%BA%AB%E6%81%A9%EF%BC%8D%E5%A1%94%E5%85%8B%E6%A2%9D%E4%BB%B6">卡罗需-库恩-塔克条件</a>（KKT条件）有如下等式：</p><script type="math/tex; mode=display">(-2\mathbf{U}+2\mathbf{SC}+4\beta\mathbf{AU}-4\beta\mathbf{UU}^T\mathbf{U})_{ij}U_{ij}=\Theta_{ij}U_{ij}=0</script><p>这是解收敛时必须满足的固定点方程。给定\(\mathbf{U}\)的初始值，\(\mathbf{U}\)的连续更新为：</p><script type="math/tex; mode=display">U_{ij}\gets U_{ij}\big(\frac{(\mathbf{SC}+2\beta\mathbf{AU}-\mathbf{U})_{ij}}{2\beta(\mathbf{UU}^T\mathbf{U})_{ij}}\big)^\frac{1}{4}</script><p>为了保证\(\mathbf{U}\)非负的属性，将\(\mathbf{A}\)中的对角元素设置为大于\(\frac{1}{2\beta}\)。\(\mathbf{U}\)的更新规则满足以下定理以保证规则的正确性。</p><ul><li><p><strong>定理1</strong></p><blockquote><p>如果U的更新规则收敛，则最终解满足KKT最优条件。</p></blockquote></li><li><p><strong>定义1</strong></p><blockquote><p>当函数\(Q(\mathbf{U},\mathbf{U}’)\ge L(\mathbf{U})\)，\(Q(\mathbf{U},\mathbf{U})=L(\mathbf{U})\)时，\(Q(\mathbf{U},\mathbf{U}’)\)是\(L(\mathbf{U})\)的辅助函数。</p></blockquote></li><li><p><strong>引理1</strong></p><blockquote><p>如果\(Q\)是\(L\)的辅助函数，则\(L\)在更新规则\(\mathbf{U}^{(t+1)}=arg\min_\mathbf{U}Q(\mathbf{U},\mathbf{U}^{(t)})\)下不增加。</p></blockquote></li><li><p><strong>引理2</strong></p><blockquote><p>函数</p><script type="math/tex; mode=display">Q(\mathbf{U},\mathbf{U}')=tr(\mathbf{SCC}^T\mathbf{S}^T+\beta\mathbf{AA})-\beta tr(\mathbf{RU'}^T\mathbf{U'U'}^T)-tr(\mathbf{U'}^T\mathbf{A'Z})\\\\\quad\quad\quad\quad\quad-tr(\mathbf{Z}^T\mathbf{A'U'})-tr(\mathbf{U'}^T\mathbf{A'U'})-2tr(\mathbf{C}^T\mathbf{S}^T\mathbf{Z})-2tr(\mathbf{C}^T\mathbf{S}^T\mathbf{U'})</script><p>是\(L(\mathbf{U})\)的辅助函数，其中\(R_{ij}=\frac{U_{ij}^4}{U_{ij}’^3}\)，\(Z_{ij}=U’_{ij}\ln\frac{U_{ij}}{U’_{ij}}\)，\(\mathbf{A}’=2\beta\mathbf{A}-\mathbf{I}\)，且\(\mathbf{I}\)是单位矩阵。</p></blockquote></li><li><p><strong>定理2</strong></p><blockquote><p>在\(\mathbf{U}\)的迭代更新下<em>U</em>问题是非增的。</p></blockquote></li></ul><h2 id="C问题"><a href="#C问题" class="headerlink" title="C问题"></a><em>C</em>问题</h2><p>当固定\(\mathbf{U}\)更新\(\mathbf{C}\)时，需要解决以下问题：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{C}\ge0}L(\mathbf{C})=\|\mathbf{U}-\mathbf{SC}\|_F^2+\alpha\sum_{j=1}^k\|\mathbf{C}(:,j)\|_1^2</script><p>它等价于如下优化问题：</p><script type="math/tex; mode=display">\min\limits_{\mathbf{C}\ge0}L(\mathbf{C})=\|\dbinom{\mathbf{S}}{\sqrt{\alpha}\mathbf{e}_{1\times m}}\mathbf{C}-\dbinom{\mathbf{U}}{\mathbf{0}_{1\times k}}\|_F^2</script><p>其中\(\mathbf{e}_{1\times m}\)是一个所有分量为1行向量，\(\mathbf{0}_{1\times k}\)是0向量。因此对上面的问题有以下规则：</p><script type="math/tex; mode=display">\mathbf{C}_{ij}\gets\mathbf{C}_{ij}\frac{(\mathbf{S'}^T\mathbf{U'})_{ij}}{(\mathbf{S'}^T\mathbf{S'C})_{ij}}</script><p>其中\(\mathbf{S’}=\dbinom{\mathbf{S}}{\sqrt{\alpha}\mathbf{e}_{1\times m}}\)且\(\mathbf{U’}=\dbinom{\mathbf{U}}{\mathbf{0}_{1\times k}}\)。</p><p>在融合中，由于\(\mathbf{U}\)表达了社团成员软关系分布，可以直接使用\(\mathbf{U}\)或\(\mathbf{U}=\mathbf{SC}\)来获得最终的不相交或重叠的社团。每列\(\mathbf{C}\)表示社团与属性之间的关系，值越大表示与社团对应的属性越相关。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.cse.wustl.edu/~zhang/publications/aaai16-attributenetworks.pdf&quot;&gt;Semantic community identification in </summary>
      
    
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LINE：大规模信息网络嵌入</title>
    <link href="https://liangzhenduo0608.github.io/posts/line/"/>
    <id>https://liangzhenduo0608.github.io/posts/line/</id>
    <published>2017-04-15T07:15:15.000Z</published>
    <updated>2019-07-14T15:04:34.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://arxiv.org/pdf/1503.03578.pdf">LINE: Large-scale Information Network Embedding</a><br>源码：<a href="https://github.com/tangjianpku/LINE">tangjianpku/LINE</a></p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这篇论文提出了一种将大规模信息网络嵌入到低维向量空间中的方法，适用于有向、无向、有权、无权图。该方法用了精心设计的目标函数，保留了局部和全局网络结构。边采样方法克服了传统梯度下降法的局限性，提高了效率和效果。</p><h1 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h1><h2 id="信息网络"><a href="#信息网络" class="headerlink" title="信息网络"></a>信息网络</h2><p>信息网络定义为\(G=(V, E)\)，\(V\)是点集，\(E\)是边集。每条边是有序对\(e=(u, v)\)且有大于0的权重\(w_{u,v}\)来表示关系强度（该问题中不考虑负权）。无向图认为双向边相等。<br>把信息网络嵌入到低维空间非常有用，但要执行嵌入必须先保留网络结构。</p><h2 id="一阶接近度"><a href="#一阶接近度" class="headerlink" title="一阶接近度"></a>一阶接近度</h2><p>网络中的一阶接近度是指两点间的局部成对相似度。连接点对的<strong>边之权重表示两点间的一阶接近度</strong>，若无边则一阶接近度是0。一阶接近度通常暗含真实网络中两点的相似度，但被观测到的边只占很小一部分，未观测到的一阶接近度被视作0，因此一阶接近度不足以保留网络结构。</p><h2 id="二阶接近度"><a href="#二阶接近度" class="headerlink" title="二阶接近度"></a>二阶接近度</h2><p>点对间的二阶接近度是它们邻居网络结构的相似度。用\(p_u=(w_{u,1},\ldots,w_{u,|V|})\)表示\(u\)到其他节点的一阶接近度，<strong>二阶接近度就是\(p_u\)和\(p_v\)（一阶接近度）的相似度</strong>。如果没有节点与\(u\)和\(v\)相连，则二阶接近度为0。</p><h2 id="大规模信息网络嵌入"><a href="#大规模信息网络嵌入" class="headerlink" title="大规模信息网络嵌入"></a>大规模信息网络嵌入</h2><p>给出大型网络\(G=(V, E)\)，信息网络嵌入旨在把每个节点\(v\)表示到低维空间\(R^d\)中，学习一个函数\(f_G:V\to R^d\)其中\(d\ll |V|\)。在空间\(R^d\)中一阶接近度和二阶接近度都保留着。</p><h1 id="LINE模型"><a href="#LINE模型" class="headerlink" title="LINE模型"></a>LINE模型</h1><p>合格的真实世界信息网络嵌入模型要满足以下条件：</p><ul><li>保留节点间的一阶接近度和二阶接近度</li><li>可用于大型网络</li><li>可以处理有向／无向／有权／无权图</li></ul><h2 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h2><h3 id="一阶接近度的LINE"><a href="#一阶接近度的LINE" class="headerlink" title="一阶接近度的LINE"></a>一阶接近度的LINE</h3><p>对于每条无向边\((i, j)\)，定义\(v_i\)和\(v_j\)的连接概率为：</p><script type="math/tex; mode=display">p_1(v_i, v_j)=\frac{1}{1+\exp(-\overrightarrow{u_i}^T\cdot\overrightarrow{u_j})}</script><p>其中\(\overrightarrow{u_i}\)是\(v_i\)的低维向量表示。上式定义的\(V \times V\)空间内的分布，经验分布\(\hat{p_1}(i, j)=\frac{w_{ij}}{W}\)，其中\(W=\sum_{(i,j)\in{E}}{w_{ij}}\)。为了保留一阶接近度，简单的方法是减小以下目标函数：</p><script type="math/tex; mode=display">O_1=d(\hat{p_1}(\cdot, \cdot), {p_1}(\cdot, \cdot))</script><p>其中\(d(\cdot, \cdot)\)是两个分布之间的距离。减小两个概率分布的<a href="https://zh.wikipedia.org/zh-hans/%E7%9B%B8%E5%AF%B9%E7%86%B5">KL散度</a>，用KL散度替换距离函数并去掉常量后得到：</p><script type="math/tex; mode=display">O_1=-\sum_{(i,j)\in{E}}{w_{ij}\log{p_1(v_i,v_j)}}</script><p>注意<strong>一阶接近度仅适用于无向图</strong>。找到减小上式的\(\left\{\overrightarrow{u_i}\right\}_{i=1..|V|}\)就可以表示d维空间内的每个点。</p><h3 id="二阶接近度的LINE"><a href="#二阶接近度的LINE" class="headerlink" title="二阶接近度的LINE"></a>二阶接近度的LINE</h3><p><strong>二阶接近度适用于有向图和无向图</strong>。给出一般网络，假设其有向。二阶接近度假设节点与其他节点共享多条连接，这种情况下每个节点都有独特的<em>环境（context）</em>且在<em>环境</em>上分布相似的节点被假设为相似的。因此每个节点扮演两种角色：节点本身和其他节点的外部<em>环境</em>。引入两个向量\(\overrightarrow{u_i}\)和\(\overrightarrow{u_i}’\)，其中\(\overrightarrow{u_i}\)表示作为节点的\(v_i\)，\(\overrightarrow{u_i}’\)表示作为<em>环境</em>的\(v_i\)。对于每个有向边\((i,j)\)首先定义<em>环境</em>\(v_j\)生成节点\(v_i\)的概率：</p><script type="math/tex; mode=display">p_2(v_j\mid v_i)=\frac{\exp({\overrightarrow{u_j}'}^T\cdot\overrightarrow{u_i})}{\sum_{k=1}^{|V|}\exp({\overrightarrow{u_k}'^T\cdot\overrightarrow{u_i})}}</script><p>其中\(|V|\)是节点或<em>环境</em>的数量。对于每个节点\(v_i\)，上式确定了环境上的条件分布。为保留二阶接近度，应当由低维表示确定条件分布来接近经验分布\(\hat{p_2}(\cdot|v_i)\)，因此减小以下目标函数：</p><script type="math/tex; mode=display">O_2=\sum_{i\in{V}}\lambda_{i}d(\hat{p_2}(\cdot\mid v_i),p_2(\cdot\mid v_i))</script><p>其中\(d(\cdot, \cdot)\)是两个分布之间的距离，由于网络中节点的重要性可能不同，引入\(\lambda_i\)来表示网络中节点\(i\)可通过算法用度或相似度来衡量的重要性。经验分布\(\hat{p_2}(\cdot\mid v_i)\)定义为\(\hat{p_2}(v_j\mid v_i)=\frac{w_{ij}}{d_i}\)，其中\(w_{ij}\)是边\((i, j)\)的权重，\(d_i\)是节点\(i\)的出度。为了简化，引入KL散度作为距离函数，将\(\lambda_i\)设为度\(d_i\)并去掉常量后得到：</p><script type="math/tex; mode=display">O_2=-\sum_{(i,j)\in{E}}w_{ij}\log{p_2(v_j\mid v_i)}</script><p>通过学习\(\left\{\overrightarrow{u_i}\right\}_{i=1..|V|}\)和\(\left\{\overrightarrow{u_i}’\right\}_{i=1..|V|}\)减小这项，就可以用d维向量\(\overrightarrow{u_i}\)表示每个节点\(v_i\)。</p><h3 id="结合一阶二阶接近度"><a href="#结合一阶二阶接近度" class="headerlink" title="结合一阶二阶接近度"></a>结合一阶二阶接近度</h3><p>简单有效的方法是分别求出一阶二阶接近度，然后对每个节点把两种方法的嵌入训练组合起来。更正规的方法是结合两个接近度联合训练两个目标函数。</p><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>优化\(O_2\)计算代价很高，因为在计算条件概率\(p_2\)时要累加全部节点。于是引入<a href="http://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf">mikolov2013distributed</a>中提出的<em>负采样（negative sampling）</em>，根据每个边\((i, j)\)的噪声分布取样多个负边，特别对每个边指定了以下函数：</p><script type="math/tex; mode=display">\log\sigma(\overrightarrow{u_j}'^T\cdot\overrightarrow{u_i})+\sum_{i=1}^K E_{v_n\sim P_n(v)}[\log\sigma(-\overrightarrow{u_n}'^T\cdot\overrightarrow{u_i})]</script><p>其中\(\sigma(x)=1/(1+\exp(-x))\)。第一项构造观测边，第二项构造由噪声分布画出的负边，\(K\)是负边数。令\(P_n(v)\propto d_v^{3/4}\)，其中\(d_v\)是节点\(v\)的出度。<br>对于\(O_1\)存在<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%87%A1_%28%E6%95%B8%E5%AD%B8%29#.E5.B9.B3.E5.87.A1.E8.A7.A3">平凡解</a>：当\(i\)取\(1,\ldots,|V|\)，\(k\)取\(1,\ldots,d\)时\(u_{ik}=\infty\)。为了避免平凡解可以使用把\(\overrightarrow{u_j}’^T\)改为\(\overrightarrow{u_i}\)的负采样方法。<br>引用<a href="http://papers.nips.cc/paper/4390-hogwild-a-lock-free-approach-to-parallelizing-stochastic-gradient-descent.pdf">recht2011hogwild</a>中提出的<em>异步随机梯度算法（ASGD）</em>来优化上式。每一步算法采样少量边然后更新模型参数。如果边\((i, j)\)被采样了，节点\(i\)的嵌入向量\(\overrightarrow{u_i}\)是：</p><script type="math/tex; mode=display">\frac{\partial O_2}{\partial \overrightarrow{u_i}}=w_{ij}\cdot\frac{\partial\log{p_2}(v_j\mid v_i)}{\partial \overrightarrow{u_i}}</script><p>注意梯度要乘边权，当边权差距很大时会难以找到好的学习速率。如果根据小权边确定了大的学习速率，会造成大权边的梯度爆炸，因为在根据大权边选择学习速率时梯度会变得很小。</p><h3 id="通过边采样优化"><a href="#通过边采样优化" class="headerlink" title="通过边采样优化"></a>通过边采样优化</h3><p>简单的解决方案是将权为\(w\)的边展开成\(w\)个<em>二元边（binary edges）</em>，但是会显著提高内存需求，尤其是当边权非常大时。解决这种问题的一种方法是从原始边进行采样并转换为<em>二元</em>边，通过采样率按比例还原原始边。然后问题就退化成了如何根据权重采样边。<br>令\(W=(w_1,\ldots,w_{|E|})\)表示边权序列，边权和\(w_{sum}=\sum_{i=1}^{|E|}w_i\)，然后在\(\left[0,w_{sum}\right]\)取随机数，看它落在\(\left[\sum_{j=0}^{i-1}w_j,\sum_{j=0}^iw_j\right)\)的哪个区间内。这种方法用\(O(|E|)\)的复杂度，当边数非常大时会很耗时。所以引用<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.675.8158&amp;rep=rep1&amp;type=pdf">li2014reducing</a>中提出的<em>别名法（alias method）</em>只用\(O(1)\)的复杂度就能从同一离散分布中刻画样本。用负采样可以将常数时间优化到\(O(d(K+1))\)次，其中\(K\)是负采样数量，因此每步要做\(O(dK)\)次。在实践中发现优化步数和边数是成比例的，所以LINE的总体复杂度是\(O(dK|E|)\)，和边数是线性相关并与节点数无关。这种边采样方法提高了随机梯度下降法的效率。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><h3 id="低度节点"><a href="#低度节点" class="headerlink" title="低度节点"></a>低度节点</h3><p>一个实际问题是如何准确嵌入度很小的节点。由于其邻居节点很少，难以推断其表达式，特别是依赖其环境的二阶接近度。于是这里考虑对每个节点扩张其二阶邻居节点，也就是邻居的邻居。节点\(i\)和其二阶邻居\(j\)间的权重是：</p><script type="math/tex; mode=display">w_{ij}=\sum_{k\in N(i)}w_{ik}\frac{w_{kj}}{d_k}</script><p>在实践中只能增加与低度节点\(i\)有最大相似度\(w_{ij}\)的节点\(\{j\}\)的子集。</p><h3 id="新节点"><a href="#新节点" class="headerlink" title="新节点"></a>新节点</h3><p>另一个实际问题是如何表示新加节点。对于新节点\(i\)，如果所连节点已知就可以获得已知节点经验分布\(\hat{p_1}(\cdot, v_i)\)和\(\hat{p_2}(\cdot\mid v_i)\)。为了获得新节点的嵌入，根据\(O_1\)和\(O_2\)通过更新新节点嵌入并保持已有节点的嵌入来直接减小</p><script type="math/tex; mode=display">-\sum_{j\in{N(i)}}{w_{ji}\log{p_1(v_j,v_i)}},\quad或\quad -\sum_{j\in{N(i)}}{w_{ji}\log{p_2(v_j,v_i)}},</script><p>如果没有观测到新节点和已有节点的连接就需要其他信息，比如节点的文本信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://arxiv.org/pdf/1503.03578.pdf&quot;&gt;LINE: Large-scale Information Network Embedding&lt;/a&gt;&lt;br&gt;源码：&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DeepWalk：社会表征的在线学习</title>
    <link href="https://liangzhenduo0608.github.io/posts/deepwalk/"/>
    <id>https://liangzhenduo0608.github.io/posts/deepwalk/</id>
    <published>2017-03-28T07:15:15.000Z</published>
    <updated>2019-07-14T15:04:34.204Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://arxiv.org/pdf/1403.6652.pdf">DeepWalk: Online Learning of Social Representations</a><br>源码：<a href="https://github.com/phanein/deepwalk">phanein/deepwalk</a></p></blockquote><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><strong>DeepWalk</strong>是一种学习网络中节点的隐式表征的新颖方法。这些隐式表征把社会关系编码到统计模型易于使用的连续的向量空间中。DeepWalk使用从删减的<a href="https://zh.wikipedia.org/wiki/%E9%9A%A8%E6%A9%9F%E6%BC%AB%E6%AD%A5">随机游走</a>获得的局部信息，通过游走等价句子学习出隐式表征。DeepWalk还是可扩张的，它是一个构建增量结果的在线学习算法，并且是并行的。这些特性使其广泛适用于实际应用，如网络分类或异常检测。</p><h1 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h1><p>考虑将社会网络成员分成若干类，令\(G=(V, E)\)，其中\(V\)代表网络中的成员，\(E\)代表它们的连接，\(E\in(V\times V)\)且\(G_L=(V, E, X, Y)\)是部分标注的社会网络，满足\(X\in\mathbb{R}^{|V|\times S}\)，\(S\)是每个特征向量空间的大小，\(Y\in\mathbb{R}^{|V|\times |\mathcal{Y}|}\)，\(\mathcal{Y}\)是标签集。<br>在传统机器学习分类环境中，目标是学习一个从\(X\)的元素到标签集\(\mathcal{Y}\)的假定映射\(H\)。在这种情况下，可以利用有关嵌入到结构\(G\)的实例依赖的重要信息来取得较好的效果。<br>本文提出一种捕获网络拓扑信息的方法，在不把标签空间作为特征空间的一部分的情况下，使用无监督方法学习独立于标签分布的图结构特征。这种将结构表征和标签任务的分离避免了发生在迭代方法上的级联错误。此外相同的表征还可以用于考虑网络的多分类问题。<br>本文目标是学习\(X_E\in\mathbb{R}^{|V|\times d}\)，其中\(d\)是潜在的维数。这些低维表示是分散的，表示每个社会现象在维度子集的压缩，并且每个维度贡献一个在空间上压缩的社会概念的子集。使用这些结构特征将增加属性空间来帮助确定分类。这些特征是普遍的，并可以用于任何分类算法（包括迭代法）。</p><h1 id="学习社会表征"><a href="#学习社会表征" class="headerlink" title="学习社会表征"></a>学习社会表征</h1><p>尝试根据以下特点学习社会表征：</p><ul><li><strong>普适性</strong>：真实社会网络是不断进化的，新的社会关系不需要再次重复学习过程。</li><li><strong>团体性</strong>：隐式维度间的距离应当表示网络中相关成员的社会相似性。这样可以在网络中实现普遍化。</li><li><strong>低维性</strong>：当标记数据很少时用低维模型能更好地概括、加快收敛和推断。</li><li><strong>连续性</strong>：需要隐式表征在连续空间上建模部分社团关系。为了发现社团关系的细微差别，连续表征有健壮的社团间的平滑边界。</li></ul><h2 id="随机游走"><a href="#随机游走" class="headerlink" title="随机游走"></a>随机游走</h2><p>把以节点\(v_i\)为起点的随机游走记作\(\mathcal{W}_{v_i}\)。随机游走是一个由随机变量\(\mathcal{W}_{v_i}^1,\mathcal{W}_{v_i}^2,\ldots,\mathcal{W}_{v_i}^k\)决定的随机过程，使得\(\mathcal{W}_{v_i}^{k+1}\)是从节点\(v_k\)的相邻节点中随机选择的。随机游走在内容推荐和社团发现中被用于衡量相似度。它们也是在输入图的大小的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6#.E6.AC.A1.E7.BA.BF.E6.80.A7.E6.97.B6.E9.97.B4">次线性时间</a>内计算局部社团结构信息的一类<a href="https://en.wikipedia.org/wiki/Output-sensitive_algorithm">输出敏感算法</a>的基础。<br>由于这种与局部结构的联系，于是使用一个随机游走<em>流（stream）</em>作为从网络中提取信息的基本工具。除了捕获社团信息，使用随机游走作为算法的基础也提供了两个不错的属性：首先，局部探索容易并行化。许多随机游走（在不同的线程、处理器或机器上）可以同时探索一个图的不同部分。其次，依靠从短随机游走获得的信息，可以适应图形结构的小变化而不需要全局重新计算。可以用次线性时间在变化的区域进行新的随机游走来迭代更新学习的模型。</p><h2 id="连接：幂定律"><a href="#连接：幂定律" class="headerlink" title="连接：幂定律"></a>连接：幂定律</h2><p>之前用在线随机游走作为捕获图结构的雏形，现在需要一种合适的方法来捕获这些信息。如果连通图的度分布遵循<a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E5%AE%9A%E5%BE%8B">幂定律</a>（即无尺度），观测到在节点出现在短随机游走中的频率也将遵循幂定律分布。<br>自然语言中的词频遵循类似的分布，语言建模技术可以解释这种分布行为。本文核心贡献在于可以重新设计用于建模自然语言的技术来建模网络中的社团结构。</p><h2 id="语言建模"><a href="#语言建模" class="headerlink" title="语言建模"></a>语言建模</h2><p>语言建模的目的是估计特定词序列出现在语料库的可能性。给定一个词序列：</p><script type="math/tex; mode=display">W_1^n=(w_0,w_1,\ldots,w_n)</script><p>其中\(w_i\in\mathcal{V}\)（词表），要在语料库上最大化\({\rm Pr} (w_n\mid w_0,w_1,\ldots,w_{n-1})\)。最近在表征学习中的工作集中在使用概率神经网络来构建超过原始目标的语言模型一般表征。<br>本文中提出了一种通过短随机游走来探索图的语言模型。这些游走可以被认为是一种特殊语言的短句和短语；直接模拟是估计在随机游走中访问过观测点\(v_i\)之前所有节点的可能性：</p><script type="math/tex; mode=display">{\rm Pr}\big(v_i\mid (v_1,v_2,\ldots,v_{i-1})\big)</script><p>目标是学习隐式表征，不只是节点共现的概率分布，因此我们引入映射函数\(\Phi:v\in V\mapsto\mathbb{R}^{|V|\times d}\)。映射\(\Phi\)表示与图中每个节点\(v\)相关的隐式社会表征。实际上用自由参数的矩阵\(|V|\times d\)来表示\(\Phi\)。于是问题变成了估计可能性：</p><script type="math/tex; mode=display">{\rm Pr}\bigg(v_i\mid\big(\Phi(v_1),\Phi(v_2),\ldots,\Phi(v_{i-1})\big)\bigg)</script><p>然而随着游走距离的增长，计算这种条件概率变得不可行。于是在节点表征建模上产生了优化问题：</p><script type="math/tex; mode=display">\min\limits_{\Phi}\quad-\log{\rm Pr}\big(\{v_{i-w},\ldots,v_{i+w}\}\setminus v_i\mid\Phi(v_{i})\big)</script><p>用这个目标函数构建捕获节点间在局部图结构中共享相似性的表征。具有相似邻居的顶点将获得相似的表征，可以在机器学习任务上进行一般化。<br>结合缩短的随机游走和语言模型，制定了一种满足所有期望属性的方法。该方法生成存在于连续向量空间中的低维社会网络表征。它的表征编码了社团成员的隐含形式，并且由于该方法输出有用的中间表征，它可以适应变化的网络拓扑。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在任何语言建模算法中，唯一需要的输入是语料库和词表\(\mathcal{V}\)。DeepWalk考虑一组在自身语料库中减短的随机游走，且图节点作为自己的词表（\(\mathcal{V} = V\)）。尽管在训练前已知\(V\)和随机游走节点的频率分布是有益的，但对于算法而言并不是必要的。</p><h2 id="算法：DeepWalk"><a href="#算法：DeepWalk" class="headerlink" title="算法：DeepWalk"></a>算法：DeepWalk</h2><p>该算法由两个主要部分组成：<strong>随机游走生成器</strong>和<strong>更新过程</strong>。随机游走生成器在图\(G\)上均匀采样一个随机节点\(v_i\)作为随机游走\(\mathcal{W}_i\)的起点。每次游走都对上一个访问到的节点均匀随机采样一个邻节点，直到达到最大长度（\(t\)）。尽管将实验中的随机游走的长度设为定值，但对于相同长度的随机游走来说没有任何限制。这些游走可能会重新开始（回到起点），但是初步结果没有显示重新开始的任何优势。在实践中对每个起始节点指定了一些长度为\(t\)的随机游走\(\gamma\)。</p><p><img src="/img/deepwalk1.png" alt="DeepWalk"></p><p><em>算法1</em>中的<em>3～9行</em>是方法的核心。外层循环指定循环次数\(\gamma\)，从每个顶点开始随机游走。每次迭代都会在数据中形成一个<em>pass</em>，并且对<em>pass</em>上的每个节点采样一个游走。在每次<em>pass</em>开始时先生成一个随机排序来遍历节点。虽不是严格要求的，但能加速随机梯度下降的收敛。<br>在内层循环迭代图上的所有节点。对每个节点\(v_i\)生成一个随机游走\(|\mathcal{W}_{v_i}|=t\)，然后使用<a href="https://arxiv.org/pdf/1301.3781.pdf">mikolov2013efficient</a>中提出的<strong>SkipGram算法</strong>按照上面的目标函数更新表征。</p><h3 id="SkipGram"><a href="#SkipGram" class="headerlink" title="SkipGram"></a>SkipGram</h3><p><img src="/img/deepwalk2.png" alt="SkipGram"></p><p>SkipGram是一种可以使句子中出现在窗口\(w\)中的单词之间共现率最大化的语言模型。它使用独立假设近似目标函数的条件概率：</p><script type="math/tex; mode=display">{\rm Pr}\big(\{v_{i-w},\ldots,v_{i+w}\}\setminus v_i\mid\Phi(v_{i})\big)=\prod_{j=i-w\atop j\neq i}^{i+w}{\rm Pr}\big(v_j\mid\Phi(v_i)\big)</script><p><em>算法2</em>迭代窗口\(w\)（1～2行）内随机游走中的所有可能组合。映射每个顶点\(v_j\)到其当前表征向量\(\Phi(v_j)\in\mathbb{R}^d\)。</p><p><img src="/img/deepwalk3b.png" alt=""></p><p>给定\(v_j\)的表征，要最大化游走中邻节点的概率（第3行），可以使用几种选择分类器来学习这种后验分布。例如使用逻辑回归建模前面的问题将导致大量的标签。这种模型需要跨集群的庞大的计算资源。为了避免这种必要性并加快训练时间，用<strong>Hierarchical Softmax</strong>来逼近概率分布。</p><h3 id="Hierarchical-Softmax"><a href="#Hierarchical-Softmax" class="headerlink" title="Hierarchical Softmax"></a>Hierarchical Softmax</h3><p>给定\(u_k\in V\)，计算第3行的\({\rm Pr}\big(u_k\mid \Phi(v_j)\big)\)是不可行的。计算<a href="https://zh.wikipedia.org/wiki/%E9%85%8D%E5%88%86%E5%87%BD%E6%95%B0">配分函数</a>（归一化因子）代价很高，所以使用Hierarchical Softmax分解条件概率。将节点分配到二叉树的叶子，把预测问题转化为最大化层次结构中特定路径的概率。</p><p><img src="/img/deepwalk3c.png" alt=""></p><p>如果把到节点\(u_k\)的路径看作树节点序列\((b_0,b_1,\ldots,b_{\lceil\log|V|\rceil})\)，\((b_0=root,b_{\lceil\log|V|\rceil}=u_k)\)，那么：</p><script type="math/tex; mode=display">{\rm Pr}\big(u_k\mid\Phi(v_j)\big)=\prod_{l=1}^{\lceil\log|V|\rceil}{\rm Pr}\big(b_l\mid\Phi(v_j)\big)</script><p>现在\({\rm Pr}\big(b_l\mid\Phi(v_j)\big)\)可用分配给节点\(b_l\)的父节点二项分类器建模：</p><script type="math/tex; mode=display">{\rm Pr}\big(b_l\mid\Phi(v_j)\big)=1/(1+e^{-\Phi(v_j)\cdot\Psi(b_l)})</script><p>其中\(\Psi(b_l)\in\mathbb{R}^d\)是分配给\(b_l\)父节点的表征。这样就把计算\({\rm Pr}\big(u_k\mid\Phi(v_j)\big)\)的复杂度从\(O(|V|)\)降到了\(O(\log|V|)\)。<br>可以通过在随机游走中为高频节点分配较短的路径来加快训练过程。霍夫曼编码就用于减少树中高频元素的访问时间。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>模型参数集是\(\theta=\{\Phi,\Psi\}\)，其中每个大小都是\(O(d|V|)\)。用<a href="https://en.wikipedia.org/wiki/Stochastic_gradient_descent">随机梯度下降法</a>（SGD）来优化这些参数（<em>算法2</em>第4行）。使用<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95">反向传播算法</a>估计导数。SGD的学习率\(\alpha\)在训练开始时初始设置为\(2.5％\)，然后根据节点数线性下降。</p><h2 id="并行性"><a href="#并行性" class="headerlink" title="并行性"></a>并行性</h2><p>社会网络随机游走的节点和语言中的词汇频率分布都遵循幂定律，导致低频节点距离较长，因此影响\(\Phi\)的更新在本质上是稀疏的。于是在多协作的情况下使用异步随机梯度下降（ASGD）。鉴于更新是稀疏的，且没有加访问模型共享参数的锁，ASGD将达到最佳收敛率。尽管实验是在一台机器上用多线程进行，但已经证明这种技术具有高度可扩展性，并可用于超大规模的机器学习。</p><h2 id="算法变型"><a href="#算法变型" class="headerlink" title="算法变型"></a>算法变型</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>该方法的一个有趣的变型是<em>流式（streaming）</em>方法，可以在不了解整个图的情况下实现。在这种变型中图中的小游走直接传递到表征学习代码并且直接更新模型。还需要对学习过程进行一些修改。首先，使用衰减学习率可能不再可行，因为假设了对总语料库大小的认知。相反可以将学习率\(\alpha\)初始化为一个小常量。这将需要更长时间去学习，但在某些应用中可能更有价值。其次，不一定要再建立一个参数树。如果\(V\)的基数已知（或有界），可以为其最大值构建Hierarchical Softmax树。首次看到节点可以为其分配一个叶。如果能够先验估计节点频率，还可以使用霍夫曼编码来降低高频元素的访问时间。</p><h3 id="非随机游走"><a href="#非随机游走" class="headerlink" title="非随机游走"></a>非随机游走</h3><p>一些图被作为与一系列元素交互的代理而创建（如页面导航）。当通过这种非随机游走的流建图时，可以使用此过程直接提供建模。以这种方式采样的图不仅捕获与网络结构相关的信息，还有遍历路径的频率。<br>这种变型还包括语言模型。句子可被看作在经过适当设计的语言网络进行有目的地游走，并且像SkipGram这样的语言模型是为捕获这种行为而设计的。<br>这种方法可以与流式方法结合，在不断进化的网络上无需构建全图而训练特征。用这种技术维护表征可以无需处理网络规模图而实现网络规模分类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://arxiv.org/pdf/1403.6652.pdf&quot;&gt;DeepWalk: Online Learning of Social Representations&lt;/a&gt;&lt;br&gt;源码：&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="论文" scheme="https://liangzhenduo0608.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="机器学习" scheme="https://liangzhenduo0608.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PandoraBox路由器的IPv6穿透</title>
    <link href="https://liangzhenduo0608.github.io/posts/nat6/"/>
    <id>https://liangzhenduo0608.github.io/posts/nat6/</id>
    <published>2017-03-13T05:13:13.000Z</published>
    <updated>2019-07-14T15:04:34.206Z</updated>
    
    <content type="html"><![CDATA[<p>2015年年底的时候学校升级了校园网的计费系统，当时用的路由器（大概由于配置姿势不对）一直获取不到IPv6地址。好在之后每人每月给了免费5G流量，电脑直接使用IPv6的代理，免费流量只给手机用还算熬的过去，所以就一直没再折腾。直到前些天入手了一个斐讯K2，所以想碰碰运气，结果乱搞了一通就成功了。</p><p>最开始拿到学校插上网线总是未连接状态，刷了好几种固件都没用<del>，最后发现是网线水晶头接触不良</del>。由于OpenWrt对K2的支持还不是很好，可能出现WiFi不稳定的状况，最后我还是刷了一个PandoraBox，但方法是和OpenWrt通用的。</p><h1 id="获取IPv6地址"><a href="#获取IPv6地址" class="headerlink" title="获取IPv6地址"></a>获取IPv6地址</h1><p>首先更改<code>网络</code>-<code>接口</code>设置。<code>WAN</code>选用<code>DHCP客户端</code>即可，<code>WAN6</code>要用默认的<code>DHCPv6客户端</code>，但是要改成<strong>强制</strong>请求IPv6地址并<strong>禁用</strong>请求指定长度的IPv6前缀：</p><p><img src="/img/nat6wan6.png" alt="WAN6"></p><p>这时可以重新连接一下看看WAN6是否出现了IPv6地址，如果依旧没有，可以按照<a href="https://wiki.openwrt.org/doc/uci/network6?s[]=ipv6&amp;s[]=relay#upstream_configuration_for_wan_interfaces">官方文档</a>所说将<code>wan</code>的<code>ipv6</code>选项设为<code>1</code>：</p><pre><code>uci set network.wan.ipv6=&#39;1&#39;uci commit network</code></pre><p>再重新连接应当就能获取到IPv6地址了：</p><p><img src="/img/nat6interface.png" alt="接口总览"></p><h1 id="安装NAT6"><a href="#安装NAT6" class="headerlink" title="安装NAT6"></a>安装NAT6</h1><p>最早的时候使用6relayd来实现IPv6网络穿透的，但是这个软件很早之前就被弃用了，现在当然不能再使用这么古老的方法了，所以就在网上寻找新的方法，最后根据<a href="https://wiki.openwrt.org/doc/howto/ipv6.nat6">官方文档</a>发现了通过NAT6使设备获取IPv6地址的方法。</p><p>首先安装必要的软件：</p><pre><code>opkg updateopkg install kmod-ipt-nat6</code></pre><p>然后把IPv6 ULA前缀改成<code>d</code>开头的：</p><pre><code>uci set network.globals.ula_prefix=&quot;$(uci get network.globals.ula_prefix | sed &#39;s/^./d/&#39;)&quot;uci commit network</code></pre><p>官方文档对这个操作的解释是<em>默认前缀是非全局路由的地址，大多路客户端在没有全局IPv6地址的情况下只有IPv4地址，所以需要将前缀改成未使用过的全局地址的样子</em>。</p><p>接下来更改DHCP服务器的设置：</p><pre><code>uci set dhcp.lan.ra_default=&#39;1&#39;uci commit dhcp</code></pre><p>之后修改<code>/etc/sysctl.conf</code>，将以下内容加进去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv6.conf.default.forwarding&#x3D;2</span><br><span class="line">net.ipv6.conf.all.forwarding&#x3D;2</span><br><span class="line">net.ipv6.conf.default.accept_ra&#x3D;2</span><br><span class="line">net.ipv6.conf.all.accept_ra&#x3D;2</span><br></pre></td></tr></table></figure><p>最后在<code>/etc/firewall.user</code>添加防火墙规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -t nat -I POSTROUTING -s $(uci get network.globals.ula_prefix) -j MASQUERADE</span><br></pre></td></tr></table></figure><p>重启路由器后再次连接看电脑是否已经得到路由器分配的IPv6地址了：</p><p><img src="/img/nat6address.png" alt="Network"></p><h1 id="安装ShadowSocks"><a href="#安装ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h1><p>安装ShadowSocks和luci界面：</p><pre><code>opkg updateopkg install shadowsocks-libevopkg install luci-app-shadowsocks</code></pre><p>然后在<code>服务</code>-<code>ShadowSocks</code>中配置服务器信息并启用<code>ss-redir</code>模式即可：</p><p><img src="/img/nat6shadowsocks.png" alt="ShadowSocks"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2015年年底的时候学校升级了校园网的计费系统，当时用的路由器（大概由于配置姿势不对）一直获取不到IPv6地址。好在之后每人每月给了免费5G流量，电脑直接使用IPv6的代理，免费流量只给手机用还算熬的过去，所以就一直没再折腾。直到前些天入手了一个斐讯K2，所以想碰碰运气，结</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
    <category term="科学上网" scheme="https://liangzhenduo0608.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    <category term="ShadowSocks" scheme="https://liangzhenduo0608.github.io/tags/ShadowSocks/"/>
    
    <category term="OpenWrt" scheme="https://liangzhenduo0608.github.io/tags/OpenWrt/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    <category term="IPv6" scheme="https://liangzhenduo0608.github.io/tags/IPv6/"/>
    
    <category term="PandoraBox" scheme="https://liangzhenduo0608.github.io/tags/PandoraBox/"/>
    
  </entry>
  
  <entry>
    <title>路由器刷breed引导第三方固件</title>
    <link href="https://liangzhenduo0608.github.io/posts/breed/"/>
    <id>https://liangzhenduo0608.github.io/posts/breed/</id>
    <published>2017-02-24T04:12:12.000Z</published>
    <updated>2019-07-14T15:04:34.204Z</updated>
    
    <content type="html"><![CDATA[<p>之前早就听说<strong>斐讯</strong>路由器有个<em><a href="http://www.phicomm.com/cn/index.php/News/detail/cateid/2/id/372.html">0元购</a></em>活动，一直没往心里去；直到昨天看到<a href="http://weibo.com/xforce">XForce</a>大神也撸了一台，于是<del>江信江疑</del>跟风在<em>二手东</em>下了一单，结果今天就上船了，但愿30天内别翻船，才算真的免费拿到手啊。</p><p>收货后先别急刮K码，刮开了万一有毛病就不给退换了。先登<a href="http://192.168.2.1/">192.168.2.1</a>配置一下网络，发现原厂固件功能还算齐全，一般情况都够用了。但是据说有人发现路由器暗地里在给某些服务器传送着数据，恐怕有信息泄露的风险，当然刷一个第三方固件更保险一些了。</p><p>我拿到的<strong>斐讯K2</strong>硬件版本是<code>A2</code>，固件版本是<code>22.4.5.42</code>。听闻说更高版本的固件刷Breed非常麻烦，我还比较庆幸原厂版本比较低，然而依然要降级。</p><h1 id="刷入breed"><a href="#刷入breed" class="headerlink" title="刷入breed"></a>刷入breed</h1><h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p>首先下载huzibbs大神制作的<strong>路由器刷breed Web助手通用版</strong>（<a href="https://soft.ctfile.com/info/xoc403020">城通网盘</a>），可以实现一键刷telnet、ssh、breed。</p><p>然后将路由器<strong>LAN</strong>口（推荐使用LAN4口）与Windows电脑用<strong>网线</strong>相连（一定不要使用WiFi），然后长按路由器Reset键5秒恢复出厂设置。之后可以再访问一下<a href="http://192.168.2.1/">192.168.2.1</a>看是不是初始状态。</p><h2 id="开始刷机"><a href="#开始刷机" class="headerlink" title="开始刷机"></a>开始刷机</h2><p>如果一切正常就以管理员身份运行<strong>路由器刷breed Web助手通用版</strong>：</p><p><img src="/img/breedassistant.png" alt="路由器刷breed Web助手通用版"></p><p>配置如图即可，注意其中刷机方案一定要选择<code>斐讯k1,k1s,k2全自动方案</code>，然后点击<code>开始刷机</code>即可。</p><p>开始刷机前工具作者建议先手动禁用除<code>以太网</code>以外的其他网络连接。由于工具中途会调用另外几个程序，所以中途如果系统弹出了提示框允许即可，顺便设成不再提醒；如果弹窗导致刷机失败了重新再来一遍基本就可以了。<em>成功后请忽略下面的步骤，直接进入下一小节。</em></p><p>如果一直失败，出现类似ssh无法连接的错误，因为此时固件应当已经降级到有ssh的测试版本了，也可以手动ssh进去（用户名和密码都是<code>root</code>）执行刷机步骤，但此时操作一定要谨慎，否则极有可能变砖！</p><p>下载路由器对应的<a href="https://breed.hackpascal.net/">breed</a>包（如<code>breed-mt7620-phicomm-psg1208.bin</code>）下载到路由器，切记一定不要选错，然后执行：</p><pre><code>mtd unlock Bootloadermtd -r write breed-mt7620-phicomm-psg1208.bin Bootloader</code></pre><p>执行完后应当会自动重启。这种方法理论上可行，具体细节有待验证，请谨慎使用。</p><h2 id="重启路由器"><a href="#重启路由器" class="headerlink" title="重启路由器"></a>重启路由器</h2><p>几分钟之后刷机自动完成，按照工具提示<strong>等待2分钟以后</strong>再断电。在重新通电前先按住Reset键再接通电源，持续按住Reset键约5秒钟再松手。不出意外此时路由器应该进入了breed引导，这时访问<a href="http://192.168.1.1/">192.168.1.1</a>应当就进入了<strong>Breed Web 恢复控制台</strong>：</p><p><img src="/img/breedweb.png" alt="Breed Web 恢复控制台"></p><h1 id="刷入第三方固件"><a href="#刷入第三方固件" class="headerlink" title="刷入第三方固件"></a>刷入第三方固件</h1><h2 id="固件备份"><a href="#固件备份" class="headerlink" title="固件备份"></a>固件备份</h2><p>进入控制台后，先到<code>固件备份</code>里将<code>EEPROM</code>和<code>编程器固件</code>备份一下：</p><p><img src="/img/breedbackup.png" alt="固件备份"></p><h2 id="恢复出厂设置"><a href="#恢复出厂设置" class="headerlink" title="恢复出厂设置"></a>恢复出厂设置</h2><p>然后到<code>恢复出厂设置</code>将固件恢复<code>Config区（公版）</code>：</p><p><img src="/img/breedreset.png" alt="恢复出厂设置"></p><h2 id="固件更新"><a href="#固件更新" class="headerlink" title="固件更新"></a>固件更新</h2><p>最后到<code>固件更新</code>选择要刷的固件上传即可：</p><p><img src="/img/breedupdate.png" alt="固件更新"></p><p>目前K2可刷的固件有很多，包括<a href="https://downloads.openwrt.org/">OpenWrt</a>、<a href="http://downloads.pandorabox.com.cn/">PandoraBox</a>等等。虽然OpenWrt还没有放出针对K2的Release版本，但由于它用的是<strong>ramips</strong>架构的<strong>mt7620</strong>芯片，所以一般mt7620芯片的路由器固件是通用的，于是我就刷了个小米路由器的<a href="https://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7620/openwrt-15.05.1-ramips-mt7620-xiaomi-miwifi-mini-squashfs-sysupgrade.bin">固件</a>：</p><p><img src="/img/breedwrt.png" alt="OpenWrt"></p><p>而潘多拉盒子已经有了K2的稳定版<a href="http://downloads.pandorabox.com.cn/pandorabox-16-10-stable/targets/ralink/mt7620/PandoraBox-ralink-mt7620-phicomm-k2-2017-01-03-git-6c24a7a-squashfs-sysupgrade.bin">固件</a>。另外给K2装软件时记得下载<strong>ramips</strong>架构的ipk包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前早就听说&lt;strong&gt;斐讯&lt;/strong&gt;路由器有个&lt;em&gt;&lt;a href=&quot;http://www.phicomm.com/cn/index.php/News/detail/cateid/2/id/372.html&quot;&gt;0元购&lt;/a&gt;&lt;/em&gt;活动，一直没往心里去；直</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="OpenWrt" scheme="https://liangzhenduo0608.github.io/tags/OpenWrt/"/>
    
    <category term="路由器" scheme="https://liangzhenduo0608.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>树莓派SPI驱动OLED屏幕</title>
    <link href="https://liangzhenduo0608.github.io/posts/raspi-oled/"/>
    <id>https://liangzhenduo0608.github.io/posts/raspi-oled/</id>
    <published>2017-02-07T13:11:11.000Z</published>
    <updated>2019-07-14T15:04:34.207Z</updated>
    
    <content type="html"><![CDATA[<p>曾经在B站看到过有人用树莓派连接OLED屏幕播放<strong><em>Bad Apple</em></strong>（有屏幕的地方就有<strong><em>Bad Apple</em></strong>），想到前些年在智能车打酱油时遗留下的一块128*64的OLED屏幕，就想给树莓派加一个monitor。</p><h1 id="连接引脚"><a href="#连接引脚" class="headerlink" title="连接引脚"></a>连接引脚</h1><p><img src="/img/oledpin.png" alt="物理编号"></p><p>屏幕上有7个引脚，与树莓派用母对母杜邦线连接，接法如下表：</p><div class="table-container"><table><thead><tr><th>OLED引脚</th><th>功能</th><th>树莓派引脚</th><th>编号</th></tr></thead><tbody><tr><td>GND</td><td></td><td>GND</td><td>25</td></tr><tr><td>VCC</td><td></td><td>3.3V PWR</td><td>17</td></tr><tr><td>D0</td><td>SCLK</td><td>GPIO 11</td><td>23</td></tr><tr><td>D1</td><td>MOSI</td><td>GPIO 10</td><td>19</td></tr><tr><td>RST</td><td></td><td>GPIO 17</td><td>11</td></tr><tr><td>DC</td><td></td><td>GPIO 27</td><td>13</td></tr><tr><td>CS</td><td>CS0</td><td>GPIO 8</td><td>24</td></tr></tbody></table></div><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>在驱动屏幕之前要先启用SPI：</p><pre><code>sudo raspi-config</code></pre><p>然后选择<code>Advanced Options</code>里的<code>SPI</code>并启用它，然后执行<code>sudo reboot</code>重启。重启后执行<code>ls /dev | grep spi</code>，如果显示：</p><blockquote><p>spidev0.0<br>spidev0.1</p></blockquote><p>就说明设置生效了。</p><p>先安装一些要用到的Python模块：</p><pre><code>sudo apt-get install build-essential python-dev python-pipsudo apt-get install python-imaging python-smbussudo pip install RPi.GPIO</code></pre><p>然后克隆SPI的驱动模块并安装：</p><pre><code>git clone https://github.com/adafruit/Adafruit_Python_SSD1306.gitcd Adafruit_Python_SSD1306sudo python setup.py install</code></pre><h1 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h1><p>网上有人给出了Python版的测试Demo：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python/</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> Adafruit_GPIO.SPI <span class="keyword">as</span> SPI</span><br><span class="line"><span class="keyword">import</span> Adafruit_SSD1306</span><br><span class="line"><span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="keyword">import</span> ImageFont</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Raspberry Pi pin configuration:</span></span><br><span class="line">RST = <span class="number">17</span></span><br><span class="line"><span class="comment"># Note the following are only used with SPI:</span></span><br><span class="line">DC = <span class="number">27</span></span><br><span class="line">SPI_PORT = <span class="number">0</span></span><br><span class="line">SPI_DEVICE = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 128x64 display with hardware SPI:</span></span><br><span class="line">disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST, dc=DC, spi=SPI.SpiDev(SPI_PORT, SPI_DEVICE, max_speed_hz=<span class="number">8000000</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Initialize library.</span></span><br><span class="line">disp.begin()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Clear display.</span></span><br><span class="line">disp.clear()</span><br><span class="line">disp.display()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create blank image for drawing.</span></span><br><span class="line"><span class="comment"># Make sure to create image with mode &#x27;1&#x27; for 1-bit color.</span></span><br><span class="line">width = disp.width</span><br><span class="line">height = disp.height</span><br><span class="line">image = Image.new(<span class="string">&#x27;1&#x27;</span>, (width, height))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Get drawing object to draw on image.</span></span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Draw a black filled box to clear the image.</span></span><br><span class="line">draw.rectangle((<span class="number">0</span>,<span class="number">0</span>,width,height), outline=<span class="number">0</span>, fill=<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Draw some shapes.</span></span><br><span class="line"><span class="comment"># First define some constants to allow easy resizing of shapes.</span></span><br><span class="line">padding = <span class="number">1</span></span><br><span class="line">top = padding</span><br><span class="line">x = padding</span><br><span class="line"><span class="comment"># Load default font.</span></span><br><span class="line">font = ImageFont.load_default()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Alternatively load a TTF font.</span></span><br><span class="line"><span class="comment"># Some other nice fonts to try: http://www.dafont.com/bitmap.php</span></span><br><span class="line"><span class="comment">#font = ImageFont.truetype(&#x27;Minecraftia.ttf&#x27;, 8)</span></span><br><span class="line"> </span><br><span class="line">draw.text((x, top), <span class="string">&#x27;This is first line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">draw.text((x, top+<span class="number">10</span>), <span class="string">&#x27;This is second line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">draw.text((x, top+<span class="number">20</span>), <span class="string">&#x27;This is third line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">draw.text((x, top+<span class="number">30</span>), <span class="string">&#x27;This is fourth line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">draw.text((x, top+<span class="number">40</span>), <span class="string">&#x27;This is fifth line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">draw.text((x, top+<span class="number">50</span>), <span class="string">&#x27;This is last line&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Display image.</span></span><br><span class="line">disp.image(image)</span><br><span class="line">disp.display()</span><br></pre></td></tr></table></figure><p>如果运行它能正常显示就可以编写自己的脚本了。参考这个Demo我又撸了一个显示系统实时信息的脚本：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python/</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> fcntl</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> Adafruit_GPIO.SPI <span class="keyword">as</span> SPI</span><br><span class="line"><span class="keyword">import</span> Adafruit_SSD1306</span><br><span class="line"><span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> ImageDraw</span><br><span class="line"><span class="keyword">import</span> ImageFont</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">raminfo</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/meminfo&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        total = <span class="built_in">float</span>(f.readline().split()[<span class="number">1</span>])</span><br><span class="line">        free = <span class="built_in">float</span>(f.readline().split()[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">format</span>((total-free)/total, <span class="string">&#x27;.1%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diskinfo</span>():</span></span><br><span class="line">    st = os.statvfs(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    total = <span class="built_in">float</span>(st.f_blocks * st.f_frsize)</span><br><span class="line">    used = <span class="built_in">float</span>(st.f_blocks - st.f_bfree) * st.f_frsize</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">format</span>(used/total, <span class="string">&#x27;.1%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cpuinfo</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/stat&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        info = f.readline().split()</span><br><span class="line">        t0 = <span class="built_in">float</span>(info[<span class="number">1</span>]) + <span class="built_in">float</span>(info[<span class="number">2</span>]) + <span class="built_in">float</span>(info[<span class="number">3</span>])</span><br><span class="line">        s0 = t0 + <span class="built_in">float</span>(info[<span class="number">4</span>]) + <span class="built_in">float</span>(info[<span class="number">5</span>]) + <span class="built_in">float</span>(info[<span class="number">6</span>]) + <span class="built_in">float</span>(info[<span class="number">7</span>])</span><br><span class="line">    time.sleep(<span class="number">0.033</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/stat&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        info = f.readline().split()</span><br><span class="line">        t1 = <span class="built_in">float</span>(info[<span class="number">1</span>]) + <span class="built_in">float</span>(info[<span class="number">2</span>]) + <span class="built_in">float</span>(info[<span class="number">3</span>])</span><br><span class="line">        s1 = t1 + <span class="built_in">float</span>(info[<span class="number">4</span>]) + <span class="built_in">float</span>(info[<span class="number">5</span>]) + <span class="built_in">float</span>(info[<span class="number">6</span>]) + <span class="built_in">float</span>(info[<span class="number">7</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">format</span>((t1-t0)/(s1-s0), <span class="string">&#x27;.1%&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cputemp</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/sys/class/thermal/thermal_zone0/temp&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        temp = <span class="built_in">float</span>(f.readline())</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">format</span>(temp/<span class="number">1000</span>, <span class="string">&#x27;.1f&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wifiinfo</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/proc/net/wireless&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.readline()</span><br><span class="line">        f.readline()</span><br><span class="line">        info = f.readline().split()</span><br><span class="line">    <span class="keyword">return</span> info[<span class="number">3</span>][:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip_address</span>(<span class="params">ifname</span>):</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">    <span class="keyword">return</span> socket.inet_ntoa(fcntl.ioctl(</span><br><span class="line">        s.fileno(),</span><br><span class="line">        <span class="number">0x8915</span>,  <span class="comment"># SIOCGIFADDR</span></span><br><span class="line">        struct.pack(<span class="string">&#x27;256s&#x27;</span>, ifname[:<span class="number">15</span>])</span><br><span class="line">    )[<span class="number">20</span>:<span class="number">24</span>])</span><br><span class="line"></span><br><span class="line">IP = requests.get(<span class="string">&#x27;http://ip.3322.net&#x27;</span>).text</span><br><span class="line"></span><br><span class="line"><span class="comment"># Raspberry Pi pin configuration:</span></span><br><span class="line">RST = <span class="number">17</span></span><br><span class="line">DC = <span class="number">27</span></span><br><span class="line">SPI_PORT = <span class="number">0</span></span><br><span class="line">SPI_DEVICE = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 128x64 display with hardware SPI:</span></span><br><span class="line">disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST, dc=DC, spi=SPI.SpiDev(SPI_PORT, SPI_DEVICE, max_speed_hz=<span class="number">8000000</span>))</span><br><span class="line"><span class="comment"># Initialize library.</span></span><br><span class="line">disp.begin()</span><br><span class="line"><span class="comment"># Clear display.</span></span><br><span class="line">disp.clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    disp.display()</span><br><span class="line">    <span class="comment"># Create blank image for drawing.</span></span><br><span class="line">    width = disp.width</span><br><span class="line">    height = disp.height</span><br><span class="line">    image = Image.new(<span class="string">&#x27;1&#x27;</span>, (width, height))</span><br><span class="line">    <span class="comment"># Get drawing object to draw on image.</span></span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    <span class="comment"># Initialize background.</span></span><br><span class="line">    draw.rectangle((<span class="number">0</span>,<span class="number">0</span>,width,height), outline=<span class="number">0</span>, fill=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    padding = <span class="number">1</span></span><br><span class="line">    top = padding</span><br><span class="line">    x = padding</span><br><span class="line">    font = ImageFont.load_default()</span><br><span class="line"></span><br><span class="line">    draw.text((x, top), time.strftime(<span class="string">&quot; %Y-%m-%d %H:%M:%S &quot;</span>,time.localtime(time.time())), font=font, fill=<span class="number">255</span>)</span><br><span class="line">    draw.text((x, top+<span class="number">14</span>), <span class="string">&#x27;disk:&#x27;</span> + diskinfo() + <span class="string">&#x27;  RAM:&#x27;</span> + raminfo(), font=font, fill=<span class="number">255</span>)</span><br><span class="line">    draw.text((x, top+<span class="number">24</span>), <span class="string">&#x27;temp:&#x27;</span> + cputemp() + <span class="string">&#x27;C  CPU:&#x27;</span> + cpuinfo(), font=font, fill=<span class="number">255</span>)</span><br><span class="line">    draw.text((x, top+<span class="number">34</span>), <span class="string">&#x27;signal:&#x27;</span> + wifiinfo() + <span class="string">&#x27;dBm&#x27;</span>, font=font, fill=<span class="number">255</span>)</span><br><span class="line">    draw.text((x, top+<span class="number">44</span>), <span class="string">&#x27;LAN:&#x27;</span> + get_ip_address(<span class="string">&#x27;wlan0&#x27;</span>), font=font, fill=<span class="number">255</span>)</span><br><span class="line">    draw.text((x, top+<span class="number">54</span>), <span class="string">&#x27;WAN:&#x27;</span> + IP, font=font, fill=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display image.</span></span><br><span class="line">    disp.image(image)</span><br><span class="line">    disp.display()</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/img/oled.gif" alt=""></p><h1 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h1><p>先新建一个Unit配置文件：</p><pre><code>sudo vim /etc/systemd/system/oled.service</code></pre><p>内容如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[Unit]</span></span><br><span class="line">Description=oled autostart</span><br><span class="line"></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line">Type=idle</span><br><span class="line">ExecStart=/usr/bin/python /home/pi/oled.py</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后启动并加入启动项：</p><pre><code>sudo systemctl daemon-reloadsudo systemctl start oledsudo systemctl enable oled</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;曾经在B站看到过有人用树莓派连接OLED屏幕播放&lt;strong&gt;&lt;em&gt;Bad Apple&lt;/em&gt;&lt;/strong&gt;（有屏幕的地方就有&lt;strong&gt;&lt;em&gt;Bad Apple&lt;/em&gt;&lt;/strong&gt;），想到前些年在智能车打酱油时遗留下的一块128*64的OLED屏幕</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="树莓派" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="树莓派" scheme="https://liangzhenduo0608.github.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://liangzhenduo0608.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>macOS自动添加ssh密钥</title>
    <link href="https://liangzhenduo0608.github.io/posts/ssh-add/"/>
    <id>https://liangzhenduo0608.github.io/posts/ssh-add/</id>
    <published>2017-01-23T14:22:22.000Z</published>
    <updated>2019-07-14T15:04:34.207Z</updated>
    
    <content type="html"><![CDATA[<p>本来是没有这种问题的，但是自从macOS升级到<strong>Sierra 10.12</strong>以后<code>ssh-agent</code>不会自动加载密码短语了，每次重启后ssh登机器时总是提示输入密钥的密码短语，所以每次开机都要用<code>ssh-add -K ~/.ssh/id_rsa</code>将它手动添加到钥匙串中才行。</p><p>后来在<a href="https://github.com/lionheart/openradar-mirror/issues/15361#issuecomment-270242512">GitHub</a>找到了解决方案，其实就是简单配置了一下<code>~/.ssh/config</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span> *</span><br><span class="line">    UseKeychain <span class="literal">yes</span></span><br><span class="line">    AddKeysToAgent <span class="literal">yes</span></span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentityFile ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure><p>用<code>IdentityFile</code>指定要自动添加的密钥即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来是没有这种问题的，但是自从macOS升级到&lt;strong&gt;Sierra 10.12&lt;/strong&gt;以后&lt;code&gt;ssh-agent&lt;/code&gt;不会自动加载密码短语了，每次重启后ssh登机器时总是提示输入密钥的密码短语，所以每次开机都要用&lt;code&gt;ssh-add </summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/macOS/"/>
    
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/tags/macOS/"/>
    
    <category term="ssh" scheme="https://liangzhenduo0608.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>「艦これ」Android版運用</title>
    <link href="https://liangzhenduo0608.github.io/posts/kancolle-android/"/>
    <id>https://liangzhenduo0608.github.io/posts/kancolle-android/</id>
    <published>2016-11-27T14:22:22.000Z</published>
    <updated>2019-07-14T15:04:34.205Z</updated>
    
    <content type="html"><![CDATA[<p>舰队Collection之前出了Android版，最开始需要预约抽签才能登录，2016年8月份开始全体提督都可以玩了。Android版有一个好处就是（除首次登录外）<strong>无需代理</strong>即可随时随地肝船了。</p><h1 id="下载安装DMM-Game-Store"><a href="#下载安装DMM-Game-Store" class="headerlink" title="下载安装DMM Game Store"></a>下载安装DMM Game Store</h1><p>先到<a href="http://www.dmm.com/app/-/appstore/download/">DMM App Store</a>下载<a href="http://portalapp.dmm.com/dmmappstore/DMMGameStore.apk">安装包</a>，安装完毕打开任意代理（只要不是中国大陆的地址就行）后打开游戏中心，点右上角游戏按钮登录：</p><p><img src="/img/kcastore.png" alt="DMM Game Store"></p><p>登录后选择<strong>艦隊これくしょん -艦これ-</strong>并下载：</p><p><img src="/img/kcadownload.png" alt="ダウンロード"></p><h1 id="安装运行「艦これ」"><a href="#安装运行「艦これ」" class="headerlink" title="安装运行「艦これ」"></a>安装运行「艦これ」</h1><p>下载完了直接安装就行了，此时就不需要代理了，然后直接启动：</p><p><img src="/img/kcastart.png" alt="スタート"></p><p>此时按<strong><del>ミュージック</del>スタート</strong>就进入游戏了，游戏本身和网页版大同小异：</p><p><img src="/img/kcaandroid.png" alt="Kan Colle"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;舰队Collection之前出了Android版，最开始需要预约抽签才能登录，2016年8月份开始全体提督都可以玩了。Android版有一个好处就是（除首次登录外）&lt;strong&gt;无需代理&lt;/strong&gt;即可随时随地肝船了。&lt;/p&gt;
&lt;h1 id=&quot;下载安装DMM-Gam</summary>
      
    
    
    
    <category term="ACG" scheme="https://liangzhenduo0608.github.io/categories/ACG/"/>
    
    <category term="艦隊これくしょん" scheme="https://liangzhenduo0608.github.io/categories/ACG/%E8%89%A6%E9%9A%8A%E3%81%93%E3%82%8C%E3%81%8F%E3%81%97%E3%82%87%E3%82%93/"/>
    
    
    <category term="Android" scheme="https://liangzhenduo0608.github.io/tags/Android/"/>
    
    <category term="舰队Collection" scheme="https://liangzhenduo0608.github.io/tags/%E8%88%B0%E9%98%9FCollection/"/>
    
    <category term="游戏" scheme="https://liangzhenduo0608.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>终端开发终极配置</title>
    <link href="https://liangzhenduo0608.github.io/posts/terminal/"/>
    <id>https://liangzhenduo0608.github.io/posts/terminal/</id>
    <published>2016-11-11T13:11:11.000Z</published>
    <updated>2019-11-01T14:49:37.548Z</updated>
    
    <content type="html"><![CDATA[<p>终端是每天要用到的工具，所以一定要配置成自己顺手的，才能发挥更高的效率。<strong>iTerm2+zsh+vim</strong>是我目前用过的感觉最强大的配置方案了。</p><h1 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h1><p><a href="https://www.iterm2.com/">iTerm2</a>是默认终端的终极替代方案，个性化、热键等方面表现非常出色，兼容性也非常好。</p><p><img src="/img/teriterm.png" alt="iTerm2"></p><p>直接到其<a href="https://www.iterm2.com/downloads.html">官网</a>下载安装即可。</p><p>对于终端里的特殊字符可能有的无法显示，要安装<code>powerline</code>字体：</p><pre><code>git clone https://github.com/powerline/fonts.git --depth=1cd fonts &amp;&amp; ./install.sh</code></pre><p>然后在Preferences - Profiles - Text - Font里选择powerline字体就可以了。</p><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><p><strong>zsh</strong>在命令补全等很多方面上比bash智能很多，首先切换到zsh：</p><pre><code>chsh -s /bin/zsh</code></pre><p><a href="http://ohmyz.sh/">oh-my-zsh</a>是一个管理zsh配置的框架，包含各种插件和主题，可用以下脚本安装：</p><pre><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></pre><p><img src="/img/terzsh.png" alt="oh-my-zsh"></p><p>安装完成后编辑<code>~/.zshrc</code>，可以编辑<code>ZSH_THEME</code>修改主题，或者编辑<code>plugins</code>增加插件，对应的文件分别在<code>~/.oh-my-zsh/themes</code>和<code>~/.oh-my-zsh/plugins</code>下。</p><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p><a href="http://vim.spf13.com/">spf13-vim</a>是vim的终极配置之一，用以下脚本安装：</p><pre><code>curl https://j.mp/spf13-vim3 -L &gt; spf13-vim.sh &amp;&amp; sh spf13-vim.sh</code></pre><p><img src="/img/tervim.png" alt="spf13-vim"></p><p>配色文件在<code>~/.vim/bundle/vim-colorschemes/colors</code>下，指定名称修改配色：</p><pre><code>echo colorscheme $colorscheme_name  &gt;&gt; ~/.vimrc.local</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;终端是每天要用到的工具，所以一定要配置成自己顺手的，才能发挥更高的效率。&lt;strong&gt;iTerm2+zsh+vim&lt;/strong&gt;是我目前用过的感觉最强大的配置方案了。&lt;/p&gt;
&lt;h1 id=&quot;iTerm2&quot;&gt;&lt;a href=&quot;#iTerm2&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    <category term="＊nix" scheme="https://liangzhenduo0608.github.io/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/%EF%BC%8Anix/"/>
    
    
    <category term="Linux" scheme="https://liangzhenduo0608.github.io/tags/Linux/"/>
    
    <category term="macOS" scheme="https://liangzhenduo0608.github.io/tags/macOS/"/>
    
    <category term="Unix" scheme="https://liangzhenduo0608.github.io/tags/Unix/"/>
    
    <category term="shell" scheme="https://liangzhenduo0608.github.io/tags/shell/"/>
    
  </entry>
  
</feed>
